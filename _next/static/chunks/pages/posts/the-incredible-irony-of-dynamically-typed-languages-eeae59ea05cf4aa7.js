(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[859],{3448:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/the-incredible-irony-of-dynamically-typed-languages",function(){return a(3511)}])},3511:function(e,t,a){"use strict";a.r(t),a.d(t,{useTOC:function(){return s}});var o=a(2676),n=a(2821),r=a(9075),i=a(1426);function s(e){return[]}t.default=(0,n.c)(function(e){let t={p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"I come with an extremely strong bias, which is that computers should juggle meaningless minutia, freeing people up to work on more interesting, domain driven problems that actually provide value to the world. In computer programming, the best tool that we have to juggle this meaningless minutia is something called a “type system”, and a very expressive type system like the ones provided in languages such as Haskell allow you to model your domain in code. With the help from tools, languages, and research that’s been around for decades, we can get pretty far with our computer-aided tools. However, the incredible irony is that programmers, whose only job it is to build computers and programs that help us, don’t want to use the tools that we have available to us, that make our jobs as programmers sane. Especially when working on teams with multiple people with serious production codebases that are more than 10 lines of code doing real work such as moving money, or handling your medical records."}),"\n",(0,o.jsx)(t.p,{children:"I find it astounding that entire programming languages and entire industries have been built on disregarding good ideas from the past, so programmers can ship bug after bug caused by “undefined is not a function” or “key foo not found in bar”, or “I expected a Post here, but you gave me a User instead”. Even worse is when the errors are non-trivial, and are deadly silent bugs that would’ve easily been caught by a type system. Our goal as programmers should be to turn as many domain errors into type errors as possible, so the computer can catch our mistakes and we can go on with our lives. Whenever we need to make important changes to our codebase, we should be able to be focused on solving the actual domain specific problem at hand, instead of having to search through the entire codebase to figure out what data structures, functions, or other pieces were affected because of a particular change that was made. We have tools to help us do this, but we code like we’re in the stone age."}),"\n",(0,o.jsx)(t.p,{children:"I’ll be frank. I find this type (no pun intended) of programming insane. Coming back to the point I mentioned earlier, isn’t it amazing that programmers build things to automate so much minutia away but we don’t want to give away control for our own jobs, to a set of tools that could make our jobs so much more interesting than having to spend hours upon hours asking meaningless questions about your code that a tool should answer for you? When a computer can help us write code, we find every excuse to not learn how to use it (e.g. it “slows me down”) and use subpar tools that rely on exerting double or triple the mental effort and time, just to get more buggy code. That mental effort isn’t going toward expanding your mind, learning new ideas, or finding better ways solve problems in your code or in the real world, it’s “where the heck am I using this argument inside this data structure I just changed” or “what is the value or shape of the data I’m passing in here”, AKA meaningless questions that programmers, who get paid so much money, should not be spending half their time thinking about (if you think half is an exaggeration, it’s not off by much when compared to the reality)."}),"\n",(0,o.jsx)(t.p,{children:"Don’t get me wrong, I want to get paid as much as the next person. However, it’s astounding that we are as efficient as we are, given how much time we waste on nonsense that doesn’t have to do with actually solving problems and/or developing more knowledge. Then again, the world is so inefficient that even our inefficiency looks super productive in comparison. That’s the only explanation I think of for how we’ve gotten this far and how we get paid so much given so much code out there is just jungle science and written with very little rigor or attention, using world-class tools that people should be using but don’t."}),"\n",(0,o.jsx)(t.p,{children:"There’s light at the end of the tunnel though. Programmers are starting to realize that when they work in a team of more than one person, and their codebase becomes completely unmaintainable within a few years, that there must be a better way. And it turns out there is, not because people have new ideas on how to do things, but because ideas that existed for decades are finally being taken seriously by more than a small handful of passionate programmers. TypeScript is mainstream. Rust is seeing a lot of interest from big and small companies alike, and Rust’s most unique feature (compile-time memory handling with no garbage collector at runtime) is possible because of research on type systems. Haskell is starting to see more serious interest not just from larger companies, but from startups that are taking off."}),"\n",(0,o.jsx)(t.p,{children:"A lot of effort into the more niche statically-typed functional programming languages and tools (e.g. Haskell, OCaml) has come from volunteer efforts and a few notable companies, as the number of industrial programmers in these ecosystems is still quite small. As more young companies develop talented engineers that push forward serious, statically-typed languages to do real work that can manage the insane complexity behind large-scale software, there’s hope yet that programming will eventually become sane, and the tools, much more sophisticated. That’s a future I can get behind."})]})},"/posts/the-incredible-irony-of-dynamically-typed-languages",{filePath:"pages/posts/the-incredible-irony-of-dynamically-typed-languages.md",timestamp:1729309244e3,pageMap:r.v,frontMatter:{title:"The incredible irony of dynamically-typed languages",author:"Ani Ravi",date:"2021-05-11",tag:"Programming, Types, Languages, Dynamic",description:"Dynamically-typed programming sucks in a real, production codebase. Or anything with more than 10 lines of code."},title:"The incredible irony of dynamically-typed languages"},"undefined"==typeof RemoteContent?s:RemoteContent.useTOC)},9075:function(e,t,a){"use strict";a.d(t,{v:function(){return o}});let o=[{name:"index",route:"/",frontMatter:{type:"page",title:"Home"}},{name:"posts",route:"/posts",children:[{name:"an-underrated-part-of-using-graphql",route:"/posts/an-underrated-part-of-using-graphql",frontMatter:{title:"An underrated part of using GraphQL",author:"Ani Ravi",date:new Date(16760736e5),tag:"Programming, GraphQL, Libraries",description:"Consistent naming."}},{name:"first-product-journey",route:"/posts/first-product-journey",frontMatter:{title:"The short-lived journey of our first product",author:"Ani Ravi",date:new Date(15821568e5),tag:"Pepper, Product, Startups",description:"The story of Pepper, our first app.",image:"/images/pepperlogo.png"}},{name:"index",route:"/posts",frontMatter:{type:"posts",title:"Posts"}},{name:"learning-graphql-through-postgraphile",route:"/posts/learning-graphql-through-postgraphile",frontMatter:{title:"Learning GraphQL through PostGraphile",author:"Ani Ravi",date:new Date(15971904e5),tag:"GraphQL, PostGraphile",description:"You will learn about SQL too"}},{name:"long-term-vs-short-term-career-choices",route:"/posts/long-term-vs-short-term-career-choices",frontMatter:{title:"Long-term vs short-term career choices",author:"Ani Ravi",date:new Date(17278272e5),tag:"Career, Life",description:"What differentiates long-term winners from everyone else?"}},{name:"move-off-orms-in-typescript",route:"/posts/move-off-orms-in-typescript",frontMatter:{title:"Migrating away from query builders and ORMs in JavaScript and TypeScript",author:"Ani Ravi",date:new Date(159192e7),tag:"ORMs, JavaScript, TypeScript",description:"Alternatives"}},{name:"software-engineering-in-the-early-days-of-a-product",route:"/posts/software-engineering-in-the-early-days-of-a-product",frontMatter:{title:"Software engineering in the early days of a product",author:"Ani Ravi",date:new Date(16560288e5),tag:"Engineering, Technology",description:"Some things I've learned about building software in the early days of something new."}},{name:"special-about-haskell",route:"/posts/special-about-haskell",frontMatter:{title:"What’s special about Haskell if you can already program in another language?",author:"Ani Ravi",date:new Date(16162848e5),tag:"Haskell, Programming, Languages",description:"What’s special about Haskell if you can already program in another language?"}},{name:"stand-out-engineering-team",route:"/posts/stand-out-engineering-team",frontMatter:{title:"How to make an engineering team stand out",author:"Ani Ravi",date:new Date(17290368e5),tag:"Company, Startup, Engineering",description:"What many engineering teams seem to miss"}},{name:"starting-a-company",route:"/posts/starting-a-company",frontMatter:{title:"Starting a company - my final act of desperation",author:"Ani Ravi",date:new Date(17278272e5),tag:"Company, Startup",description:"When to start a company"}},{name:"the-future-of-typescript",route:"/posts/the-future-of-typescript",frontMatter:{title:"The future of TypeScript",author:"Ani Ravi",date:new Date(16760736e5),tag:"TypeScript, Programming, Effect, Functional, Libraries",description:"This set of libraries will revolutionize how we write TypeScript."}},{name:"the-incredible-irony-of-dynamically-typed-languages",route:"/posts/the-incredible-irony-of-dynamically-typed-languages",frontMatter:{title:"The incredible irony of dynamically-typed languages",author:"Ani Ravi",date:new Date(16206912e5),tag:"Programming, Types, Languages, Dynamic",description:"Dynamically-typed programming sucks in a real, production codebase. Or anything with more than 10 lines of code."}},{name:"toy-project-not-ready-for-production",route:"/posts/toy-project-not-ready-for-production",frontMatter:{title:"Your toy project is not ready for production",author:"Ani Ravi",date:new Date(15865632e5),tag:"Toys, Project, Production, Development",description:"Tales of a developer."}},{name:"understanding-users-is-actually-difficult",route:"/posts/understanding-users-is-actually-difficult",frontMatter:{title:"Understanding users is actually difficult",author:"Ani Ravi",date:new Date(16470432e5),tag:"Startups, Users",description:"Building software is easier nowadays - figuring out what software to build is tough."}},{name:"using-elixir-in-production-at-a-small-startup",route:"/posts/using-elixir-in-production-at-a-small-startup",frontMatter:{title:"Some reflections on using elixir in production at a small startup",author:"Ani Ravi",date:new Date(16469568e5),tag:"Elixir, Programming Languages",description:"Using Elixir in production"}},{name:"why-i-bought-a-framework-laptop",route:"/posts/why-i-bought-a-framework-laptop",frontMatter:{title:"Why I bought a Framework laptop",author:"Ani Ravi",date:new Date(16374528e5),tag:"Passion",description:"A company that deserves to exist."}},{name:"working-on-things-that-are-fun-but-dont-matter",route:"/posts/working-on-things-that-are-fun-but-dont-matter",frontMatter:{title:"Working on things that are fun, but don’t matter",author:"Ani Ravi",date:new Date(15964992e5),tag:"Work, Passion",description:"Not everything is worth working on."}},{name:"your-database-is-all-your-are",route:"/posts/your-database-is-all-your-are",frontMatter:{title:"Your database is all you are",author:"Ani Ravi",date:new Date(16162848e5),tag:"PostgreSQL, Databases",description:"Get serious about your data"}}]},{name:"tags",route:"/tags",children:[]}]}},function(e){e.O(0,[821,888,774,179],function(){return e(e.s=3448)}),_N_E=e.O()}]);