(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[851],{7156:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/using-elixir-in-production-at-a-small-startup",function(){return a(8142)}])},8142:function(e,t,a){"use strict";a.r(t),a.d(t,{__toc:function(){return l}});var o=a(2676),i=a(5715),r=a(401),n=a(6825);a(5155);var s=a(5674);let l=[];function u(e){let t=Object.assign({p:"p",a:"a"},(0,s.a)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"If you've read my previous blog posts, you know that I'm generally biased toward languages that have strong static analysis tools, so less stuff gets put in production that isn't verified by a compiler. However, it's almost inevitable in your programming journey nowadays that you will work in some language with almost no static analysis tooling, at least at most young companies. As much as I love tools that can make programming more sane, it's also the case that programming tools still have a lot of room for improvement, to help aid programmers rather than needing to spend too much time type-wrangling or dealing with unclear errors. I've been using Elixir for some time now, and used to have a more negative opinion of it starting out, primarily because dealing with constant runtime errors was super annoying (still is) and it felt slow to build new features when having to keep all the information in my head. While there are some shortcomings in terms of things I like having in a language, some of Elixir's tools are great."}),"\n",(0,o.jsxs)(t.p,{children:['Most people often talk about how networking tooling in Elixir is awesome, since communicating between processes and external servers is basically "built-in", so network clustering in Elixir (especially for building things like chat apps) is much simpler than in other languages. However, I think Elixir\'s "killer app" is ',(0,o.jsx)(t.a,{href:"https://github.com/elixir-ecto/ecto",children:"Ecto"}),", Elixir's database access library, primarily used with PostgreSQL. Ecto is pretty powerful, relies heavily on macros, and makes composing SQL (especially dynamic queries where you chain query fragments together in different situations) really easy. We make use of these aspects of Ecto heavily in production. As much as I love statically-typed languages, I don't know how to make SQL as fluid, maintainable, and as easy-to-use as Ecto does in Elixir. It's actually one of the biggest reasons why we haven't seriously looked at any other backend languages for our Elixir codebase - Ecto is just that much easier to use and makes writing new features that much faster (if anyone knows how I can get composable queries, reusable query fragments, helpers to write things like joins, and raw SQL-level performance from a language like Haskell or Rust, please let me know)!"]}),"\n",(0,o.jsxs)(t.p,{children:["Ecto combined with ",(0,o.jsx)(t.a,{href:"https://github.com/absinthe-graphql/absinthe",children:"Absinthe"})," (Elixir's premier GraphQL server library) is a really good combination to get you started - it reduces the amount of code you have to write significantly for doing data access and the performance is good enough. Ecto schemas maintain the associations between different tables, and Absinthe + Ecto can figure out how to query a good amount of data simply by using dataloader and not having to handwrite a lot of joins or other queries. Many of Elixir's most popular libraries make use of macros and DSLs to express ideas in non-standard Elixir syntax (like the two aforementioned libraries), and while it may make things a little harder to understand at the beginning of your journey with Elixir, every engineer I've worked with figures it out quickly."]}),"\n",(0,o.jsxs)(t.p,{children:["Elixir is still growing but still a fairly young ecosystem, and so there's ever more ",(0,o.jsx)(t.a,{href:"https://github.com/h4cc/awesome-elixir",children:"tools/libraries"})," being developed. It has just enough of the tracing, logging, API, security, DB, and websocket tooling that you need to build a serious app in production. It also has some insane features like being able to directly call or run your production code, and hot code reloading modules in your production process."]}),"\n",(0,o.jsx)(t.p,{children:"Every set of tools comes with tradeoffs, and different tradeoffs will affect you in different ways at different stages of your product. It's worthwhile to have periods of reflection to re-evaluate whether you're using the best tools available to you to solve the problems ahead, and thinking through how much effort it would take to change tools if needed. Elixir is mostly a simple language to learn, and can get you started fairly quickly if that's what you're looking for. It's also a decent gateway into some functional programming ideas, but if you're looking for tooling that dives headfirst into FP ideas, I would look at other languages instead. I'm not sure when or if Elixir's usage will dwindle for our product in favor of other tools, but for now, it's taken us quite far!"})]})}let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,s.a)(),e.components);return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)},pageOpts:{filePath:"pages/posts/using-elixir-in-production-at-a-small-startup.md",route:"/posts/using-elixir-in-production-at-a-small-startup",frontMatter:{title:"Some Reflections on using Elixir in Production at a Small Startup",author:"Ani Ravi",date:"2022-03-11T00:00:00.000Z",tag:"Elixir, Programming Languages",description:"Using Elixir in production"},timestamp:1727724447e3,pageMap:[{kind:"MdxPage",name:"index",route:"/",frontMatter:{type:"page",title:"Home"}},{kind:"Folder",name:"posts",route:"/posts",children:[{kind:"MdxPage",name:"first-product-journey",route:"/posts/first-product-journey",frontMatter:{title:"The Short-Lived Journey of Our First Product",author:"Ani Ravi",date:"2020-02-20T00:00:00.000Z",tag:"Pepper, Product, Startups",description:"The story of Pepper, our first app.",image:"/images/pepperlogo.png"}},{kind:"MdxPage",name:"index",route:"/posts",frontMatter:{type:"posts",title:"Posts"}},{kind:"MdxPage",name:"learning-graphql-through-postgraphile",route:"/posts/learning-graphql-through-postgraphile",frontMatter:{title:"Learning GraphQL through PostGraphile",author:"Ani Ravi",date:"2020-08-12T00:00:00.000Z",tag:"GraphQL, PostGraphile",description:"You will learn about SQL too"}},{kind:"MdxPage",name:"move-off-orms-in-typescript",route:"/posts/move-off-orms-in-typescript",frontMatter:{title:"Migrating Away From Query Builders and ORMs in JavaScript and TypeScript",author:"Ani Ravi",date:"2020-06-12T00:00:00.000Z",tag:"ORMs, JavaScript, TypeScript",description:"Alternatives"}},{kind:"MdxPage",name:"software-engineering-in-the-early-days-of-a-product",route:"/posts/software-engineering-in-the-early-days-of-a-product",frontMatter:{title:"Software Engineering in the Early Days of a Product",author:"Ani Ravi",date:"2022-06-24T00:00:00.000Z",tag:"Engineering, Technology",description:"Some things I've learned about building software in the early days of something new."}},{kind:"MdxPage",name:"special-about-haskell",route:"/posts/special-about-haskell",frontMatter:{title:"What’s special about Haskell if you can already program in another language?",author:"Ani Ravi",date:"2021-03-21T00:00:00.000Z",tag:"Haskell, Programming, Languages",description:"What’s special about Haskell if you can already program in another language?"}},{kind:"MdxPage",name:"the-incredible-irony-of-dynamically-typed-languages",route:"/posts/the-incredible-irony-of-dynamically-typed-languages",frontMatter:{title:"The Incredible Irony of Dynamically-Typed Languages",author:"Ani Ravi",date:"2021-05-11T00:00:00.000Z",tag:"Programming, Types, Languages, Dynamic",description:"Dynamically-typed programming sucks in a real, production codebase. Or anything with more than 10 lines of code."}},{kind:"MdxPage",name:"toy-project-not-ready-for-production",route:"/posts/toy-project-not-ready-for-production",frontMatter:{title:"Your Toy Project is Not Ready For Production",author:"Ani Ravi",date:"2020-04-11T00:00:00.000Z",tag:"Toys, Project, Production, Development",description:"Tales of a developer."}},{kind:"MdxPage",name:"understanding-users-is-actually-difficult",route:"/posts/understanding-users-is-actually-difficult",frontMatter:{title:"Understanding Users is Actually Difficult",author:"Ani Ravi",date:"2022-03-12T00:00:00.000Z",tag:"Startups, Users",description:"Building software is easier nowadays - figuring out what software to build is tough."}},{kind:"MdxPage",name:"using-elixir-in-production-at-a-small-startup",route:"/posts/using-elixir-in-production-at-a-small-startup",frontMatter:{title:"Some Reflections on using Elixir in Production at a Small Startup",author:"Ani Ravi",date:"2022-03-11T00:00:00.000Z",tag:"Elixir, Programming Languages",description:"Using Elixir in production"}},{kind:"MdxPage",name:"why-i-bought-a-framework-laptop",route:"/posts/why-i-bought-a-framework-laptop",frontMatter:{title:"Why I Bought a Framework Laptop",author:"Ani Ravi",date:"2021-11-21T00:00:00.000Z",tag:"Passion",description:"A company that deserves to exist."}},{kind:"MdxPage",name:"working-on-things-that-are-fun-but-dont-matter",route:"/posts/working-on-things-that-are-fun-but-dont-matter",frontMatter:{title:"Working On Things That Are Fun, But Don’t Matter",author:"Ani Ravi",date:"2020-08-04T00:00:00.000Z",tag:"Work, Passion",description:"Not everything is worth working on."}},{kind:"MdxPage",name:"your-database-is-all-your-are",route:"/posts/your-database-is-all-your-are",frontMatter:{title:"Your Database is All You Are",author:"Ani Ravi",date:"2021-03-21T00:00:00.000Z",tag:"PostgreSQL, Databases",description:"Get serious about your data"}},{kind:"Meta",data:{"software-engineering-in-the-early-days-of-a-product":"Software Engineering in the Early Days of a Product","understanding-users-is-actually-difficult":"Understanding Users is Actually Difficult","using-elixir-in-production-at-a-small-startup":"Some Reflections on using Elixir in Production at a Small Startup","why-i-bought-a-framework-laptop":"Why I Bought a Framework Laptop","the-incredible-irony-of-dynamically-typed-languages":"The Incredible Irony of Dynamically-Typed Languages","special-about-haskell":"What’s special about Haskell if you can already program in another language?","your-database-is-all-your-are":"Your Database is All You Are","learning-graphql-through-postgraphile":"Learning GraphQL through PostGraphile","working-on-things-that-are-fun-but-dont-matter":"Working On Things That Are Fun, But Don’t Matter","move-off-orms-in-typescript":"Migrating Away From Query Builders and ORMs in JavaScript and TypeScript","toy-project-not-ready-for-production":"Your Toy Project is Not Ready For Production","first-product-journey":"The Short-Lived Journey of Our First Product",index:"Posts"}}]},{kind:"Meta",data:{index:"Home"}}],flexsearch:{codeblocks:!0},title:"Some Reflections on using Elixir in Production at a Small Startup",headings:l},pageNextRoute:"/posts/using-elixir-in-production-at-a-small-startup",nextraLayout:r.ZP,themeConfig:n.Z};t.default=(0,i.j)(d)},6825:function(e,t,a){"use strict";var o=a(2676);a(5271);let i={comments:(0,o.jsx)(o.Fragment,{}),footer:(0,o.jsx)("div",{className:"my-4 border-t-2 mx-auto flex items-center sm:flex-row flex-col",children:(0,o.jsx)("p",{className:"text-sm text-gray-500",children:"Ani Ravi"})}),navs:[{url:"/feed.xml",name:"RSS"},{url:"https://github.com/aniravi24",name:"Github"}],darkMode:!0,dateFormatter:e=>new Date(e).toLocaleDateString("en-US",{day:"2-digit",year:"numeric",month:"short"})};t.Z=i}},function(e){e.O(0,[838,888,774,179],function(){return e(e.s=7156)}),_N_E=e.O()}]);