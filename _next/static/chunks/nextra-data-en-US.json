{"/posts/an-underrated-part-of-using-graphql":{"title":"An underrated part of using GraphQL","data":{"":"One thing that's underrated about using GraphQL over a REST API is that conventions are enforced (or highly recommended) with a GraphQL API. I was surprised when building apps with other engineers, realizing that engineers will sometimes use a different convention for every endpoint (and there weren't even that many endpoints). Camel case for one endpoint, snake case for another, kebab case for another, and then different casing for the query params..GraphQL is nice because it standardizes all of this. Just that alone is such a useful aspect of using GraphQL that I underappreciated."}},"/":{"title":"Home","data":{"hi-there-#Hi there üëã":"I'm Ani, a software developer who loves statically-typed functional programming, and open-source software (my current favorite library ecosystem is Effect-TS for TypeScript).Computers were built to aid us - naturally, they should help us build better programs. I care about building robust, maintainable software, and am motivated by hard problems, not building the next cool widget.You can reach me at: me at aniravi dot com"}},"/posts":{"title":"Posts","data":{}},"/posts/learning-graphql-through-postgraphile":{"title":"Learning GraphQL through PostGraphile","data":{"":"This post will not walk through how to do anything in particular‚Ää‚Äî‚Ääit‚Äôs not a tutorial. It goes through what I learned and points to tools and documentation I used to get started‚Ää‚Äî‚Ääwhich might be a good starting point for others.I recently wanted to take a jump into learning GraphQL, so I sped through this course (way shorter than it looks). For some reason, I had this mental barrier thinking GraphQL was more complicated than REST, but the fundamentals are actually quite simple. The way this course framed GraphQL made it easy to understand.I knew some friends that had used and spoke highly of PostGraphile, a tool written in TypeScript that reads your PostgreSQL database schema and generates a GraphQL API on top of it. I went through all of the documentation and ended up learning a lot more about database design in the process. In effect, by learning PostGraphile and actually trying to build an initial project with it, I learned about GraphQL and more about Postgres. It was awesome to double dip and become more familiar with some of the many powerful features Postgres has.PostGraphile forces you to think of the database as your application. Another way to do put it is that you‚Äôre doing database-driven-design. Now you might be wondering, how do you actually get work done (e.g. send emails)? One awesome tool the same folks have built is called worker. This allows you to use your database as a job queue, that your javascript code can pull jobs from and do work. Additionally, if you check out the PostGraphile documentation, there are easy ways to extend your GraphQL schema so you can add your own queries and mutations, similar to how you might do it if you had to write your own schemas and resolvers. You can use migrate to write your SQL migrations. Migrate simply has you write SQL files and the migrations run quickly.Something to note is that if you run primarily on PostGraphile, you will likely end up using Node.JS (or any compile-to-JS language, e.g. ReasonML) for anything related to PostGraphile or its workers due to the tools being written in TypeScript. Extending PostGraphile easily with plugins requires JS code in your codebase.I‚Äôm not sure if people would typically recommend learning GraphQL through a tool like this, but I found it great to get started. Anything that runs through PostGraphile‚Äôs autogenerated schema (not necessarily custom stuff you‚Äôve written) also avoids N+1 query problems, as your GraphQL query is parsed into a SQL query prior to running against your database, keeping things performant. I saved a ton of time building with PostGraphile, and you get lots of interesting benefits doing things through DB-driven design. You could build say, a user-facing API and admin API largely just by setting database permissions per table, without having to write entire APIs or dealing with security for it separately. You can build a lot more a lot faster, especially as you aren‚Äôt spending time in your REST APIs thinking specifically about what query you need to write to get certain data. You spend a lot more time in the database, but less time overall.After giving PostGraphile a try, if you use Node.JS or are willing to have part of your project in it, I would highly recommend PostGraphile!"}},"/posts/long-term-vs-short-term-career-choices":{"title":"Long-term vs short-term career choices","data":{"":"Every decision I've made in terms of work has been to follow what I'm interested in over choosing something with brand value or a significant paycheck. At my first startup, we were a bunch of nobodies that didn't make a salary for quite some time just to get the company off the ground. Looking back, that was probably one of the most formative experiences I could've had at that time in my life. When I narrate this story to other people, I realize most of my peers' experiences coming out of college were nothing like mine.The conclusion I've come to is that to have outsized long-term success, chasing things like brand or income are usually going to lead you to hitting local maxima (or as the young folks would say, you're going to \"peak\" much sooner). For some people, they peak super early, in fact, their most notable accomplishments might be in high school or college, and they go downhill from there.To win long-term, one path is to pursue opportunities where you learn as much as possible, and usually this correlates with following your interests. Or at the very least, finding a way to make the opportunities you do have as interesting to you as possible. If I really worked at it, I'm sure I could've been a good engineer at a big tech company, but I didn't have the slightest interest in preparing for technical interviews and doing work that didn't feel meaningful to me."}},"/posts/move-off-orms-in-typescript":{"title":"Migrating away from query builders and ORMs in JavaScript and TypeScript","data":{"":"Update Apr 2023: It's been years since I wrote this and my views have changed quite a bit. While I think there are certainly trade-offs with any solution, the tools in TypeScript have gotten significantly better since I wrote this. As a codebase scales and you work with a team, writing raw queries is not particularly enjoyable. It's nicer to have the shorter syntax that ORMs offer, not to mention the built-in type-checking. For example, Prisma and Kysely are two cool projects at the time of this update.I spent the better part of a day moving a project completely off of the ORM we were using (TypeORM). Ever since I started doing web development, I‚Äôve been using some kind of heavy abstraction on top of my database. Whether it‚Äôs Mongoose when I used MongoDB, or TypeORM when I decided to move to TypeScript and PostgreSQL. However, it turns out that ORMs and query builders aren‚Äôt so great. I used to be that person that thought ORMs and query builders did the job for me, and I used it as an excuse to not learn SQL (which is what everyone tells you NOT to do). Given the tools that exist today, I would wholeheartedly recommend doing it the opposite of how I did if you‚Äôre starting off new to these things‚Ää‚Äî‚Ääwrite your SQL stuff by hand, or with help from the tools I mention later in the post. It‚Äôll feel really slow at first, but you‚Äôll thank yourself later üòÑI‚Äôm going to split this post up into three different parts: First, I‚Äôll talk about why query builders and ORMs aren‚Äôt worth using. Second, I‚Äôll explore specific issues I‚Äôve had using ORMs like TypeORM‚Ää‚Äî‚Ääbugs that don‚Äôt actually exist when you directly interface with the DB using the popular driver library in your language or some helper functions. Third, I‚Äôll walk through my current preferred tooling to create an ergonomic experience with the database from a Node.js project‚Ää‚Äî‚Ääwe can replace everything the ORM used to do but better (migrations, typed database schemas and interactions, nice helper functions for simple queries, etc).","part-1-why-query-builders-and-orms-arent-worthusing#Part 1: Why query builders and ORMs aren‚Äôt worth¬†using":"Query builders (e.g. Knex.js) in general are an unnecessary abstraction on top of the database‚Ää‚Äî‚Ääjust write the SQL. Instead, you‚Äôre busy learning something on top of SQL chaining a bunch of functions together and trying to figure out how a specific tool works instead of how SQL works. You‚Äôre better off learning how SQL works instead of learning a specific query builder‚Äôs toolset. That knowledge is transferrable. SQL itself is also incredibly powerful, used everywhere, and likely won‚Äôt go away anytime soon. Even if you learn new backends or frontends, you‚Äôll still be using SQL. A lot of these benefits are lost when you only work with query builders and ORMs. Also, it can start to get frustrating sometimes when you realize that you know how to do something in SQL, that you don‚Äôt know how to do with an ORM. You‚Äôll try to do things the ‚ÄúORM‚Äù way, to use the tooling provided.Query builders and ORMs can offer things like sanitization, some type safety, and abstracting away dealing with conflicts with your primary indexes (sometimes), but these can be better handled with the tools I mention in part 3. Also, parameterized queries in node-postgres automatically sanitize your inputs‚Ää‚Äî‚Ääso the query builder doesn‚Äôt need to do that for you.Edit Dec 2020: Another thing ORMs/query builders are good for is being able to compose your queries‚Ää‚Äî‚Äädynamic queries are easier to do since they are typically chained function calls.","part-2-unnecessary-problems-and-frustrations-ive-dealt-with-using-orms-liketypeorm#Part 2: Unnecessary problems and frustrations I‚Äôve dealt with using ORMs like¬†TypeORM":"I‚Äôd often have to spend time debugging issues with the ORM, that the underlying Node.js PostgreSQL driver (the wonderful node-postgres, which I‚Äôll be calling ‚Äúpg‚Äù from now on) didn‚Äôt actually have any issues with. Let me walk through a non-exhaustive list of problems I‚Äôve had working with TypeORM. I‚Äôm picking on ORMs in general here, so this isn‚Äôt a bag on TypeORM.Trying to use it with one-off scripts, ts-node or ts-node-devI‚Äôve had strange issues trying to use TypeORM with these tools‚Ää‚Äî‚Ääit‚Äôs been somewhat unpredictable. I know that for some of the scripts, I couldn‚Äôt get the files to run with ts-node, and required compiling it to JS. As soon as I removed TypeORM and used pg, it worked as expected. Handling database connections directly with pg.Pool and tools I mention in part 3 make this easy.Working through the ORM, instead of utilizing the database¬†directlyThe problem with tools like TypeORM is your entire database is managed through the ORM. It turns out that ORMs are actually not that powerful, at least not as powerful as SQL itself is. Managing your models in TypeORM leads to a lot of limitations. For example, something I often do in my database models is keep track of when a row was last updated. Doing this in TypeORM means that you do it at the JS layer, where TypeORM will get the current JS date and insert it. The problem with this is that it‚Äôs not happening at the source of truth‚Ää‚Äî‚Ääyour database. If you try to do a query with TypeORM that doesn‚Äôt use one of its higher-level abstractions, you now have data inconsistency. You just changed some data but that column didn‚Äôt update. Instead, if you‚Äôre using Postgres, one option is to use Postgres‚Äôs triggers, so that if a row is modified at all, Postgres will do that work to figure out the rest.Another major limitation is not being able to define models outside of code written in TypeScript. We had several tables in our database that I wrote into SQL but TypeORM had no awareness of (we stopped using TypeORM for migrations first, before removing the rest of it). I could‚Äôve made model files for all of those tables so that TypeORM would be aware of them, but it wasn‚Äôt worth it. On top of this, TypeORM allows you to make junction tables when you define a many-to-many relationship for some of your information, but these can‚Äôt be queried directly without using the query builder or dropping down to plain SQL (losing all type safety).Bulky, inefficient queriesIf you use TypeORM, go try something right now. Open your ormconfig.js (or¬†.ts,¬†.json, whichever one you use) and go add ‚Äúlogging‚Äù: true. Watch the queries. You might be amazed by 1. how long they are 2. how many there are 3. how inefficient and ugly they are sometimes. For example, a query as simple as\nSELECT COUNT(‚ÄúuserId‚Äù)\nFROM users_followers\nwhere ‚ÄúuserId‚Äù=‚Äôblah-uuid'\nis actually this in TypeORM\nSELECT ‚ÄúUsers_followers_rc‚Äù.‚ÄùuserId‚Äù AS ‚ÄúparentId‚Äù, COUNT(‚Äúusers‚Äù.‚Äùid‚Äù) AS ‚Äúcnt‚Äù\nFROM ‚Äúusers‚Äù ‚Äúusers‚Äù\nINNER JOIN ‚Äúusers_followers‚Äù ‚ÄúUsers_followers_rc‚Äù\nON ‚ÄúUsers_followers_rc‚Äù.‚ÄùuserId‚Äù\nIN (‚Äòblah-uuid‚Äô)\nAND ‚ÄúUsers_followers_rc‚Äù.‚ÄùfollowerId‚Äù = ‚Äúusers‚Äù.‚Äùid‚Äù\nGROUP BY ‚ÄúUsers_followers_rc‚Äù.‚ÄùuserId‚Äù\nWe‚Äôre often told that the ORM ‚Äútakes care of the DB so you don‚Äôt have to do think about it‚Äù, but as I‚Äôve done more development, I‚Äôve learned that this is not the right approach. Your database is often the source of truth‚Ää‚Äî‚Ääand is also probably one of the slowest things in your entire stack, as it deals with stuff that‚Äôs persistent on disk, not memory like the rest of your stack probably does most of the time. Also, go check out what actually happens when you use save() in TypeORM. It makes sense when you think about it, but it‚Äôs probably more queries than you thought.ORMs also often try to support many different SQL dialects or different environments. You may find that there are specific features of a DB, say, Postgres, that you want to use. Those constructs to write better queries might not be available to you if you use an ORM. You could argue that you should aim for portability, not to be tied to a DB‚Ää‚Äî‚Ääbut we‚Äôll cross that bridge if it ever matters.Migrations? Meh..Another huge problem with ORMs is that the migrations they generate aren‚Äôt the best. For example, TypeORM will generate indices of any kind with some random string of characters. I still haven‚Äôt figured out why this is necessary unless a different dialect of SQL justifies it (I only use Postgres). So you might see a query like CREATE INDEX IDX_2123asf67s6a3agab31a instead of the default convention that Postgres uses‚Ää‚Äî‚Ääwhich is easy to understand, and easy to work with. You can probably guess what it‚Äôs called without even looking at your database because the convention Postgres already uses is pretty straightforward.Sometimes the migrations you‚Äôll get are straight-up wrong, but that‚Äôs the nature of trying to automate stuff like this. Other times, it‚Äôll add extra indices where it doesn‚Äôt need to, or you‚Äôll stare at your migration and realize that the default stuff it uses or even the quality of the query is not that great. Your migrations will look a lot cleaner written by hand. When you let your ORM handle migrations for you, it can‚Äôt be smart enough often to deal with things like altering columns. TypeORM will often drop your column and make a new one‚Ää‚Äî‚Ääthat‚Äôs not a real solution in a lot of cases, unfortunately. If you write your migration by hand, these are easily solvable problems.Your migrations may also run more slowly if you need TypeScript to be compiled first. If you need to write any migrations by hand, you may notice that when you need to auto-generate migrations again, it might change or mess with the stuff you already modified (as expected, but that‚Äôs not what you would like in the ideal world). Also, does anyone actually do down migrations? More on this below in my preferred tools for doing migrations.The defaults are not that¬†goodI noticed some of the default types TypeORM recommends from the JS layer are not likely what you want in Postgres. Don‚Äôt get me wrong‚Ää‚Äî‚Ääthis is remedied by passing in parameters in the model decorators, but if you‚Äôre relying on TypeORM to take care of it for you, these are things you won‚Äôt know about. For example, by default, TypeORM will generate a timestamp without a time zone if you use a date column. It basically makes no sense to ever do this. Use timestamptz. Also, character varying without a parameter is the same as the TEXT type in Postgres (specifically in Postgres, YMMV with other SQL dialects). Fewer characters to type for you, same underlying representation.Doesn‚Äôt feel like working with SQL (by¬†design?)ORMs are designed to make you feel like the database is abstracted to work with your language of choice. Instead of feeling like you‚Äôre working with something where people actually understand SQL and databases and are trying to make that easier for you. It often doesn‚Äôt feel like that.SQL is such a declarative language and reads like English that it‚Äôs often nicer to use it directly.No type safety once you drop away from the high-level abstractionsOne general problem with ORMs is that the type safety only exists as long as you‚Äôre working through their abstractions. Once you need to drop to SQL, you lose type safety entirely. How could we make this at least somewhat better? More on this in part 3.If I had to design an ORM from scratch, it would probably have a lot of these same problems. It‚Äôs probably better to not work with this abstraction in the first place if possible with your tooling of choice.","part-3-my-preferred-setup-getting-all-the-goodies-without-the-badstuff#Part 3: My preferred setup, getting all the goodies without the bad¬†stuff":"Now that you‚Äôve read my mini-rant, let me share what my preferred tooling is today for completely moving off ORMs and query builders, as well as what the benefits are! Can we really have our cake and eat it too?Replacing migrationsLet‚Äôs start with migrations first! This one is easy. I use https://github.com/graphile/migrate (thanks John Haley for the recommendation!)It‚Äôs super straightforward to use‚Ää‚Äî‚Ääyou write your SQL files, and run a command. You can even run a watch command that will watch your file and execute the migrations as you work on it (I‚Äôve never used this, personally). It‚Äôs also super fast‚Ää‚Äî‚Ääbecause it‚Äôs plain SQL. No JavaScript to deal with anywhere. The tool itself is built in TypeScript and uses pg under the hood. It‚Äôs fast.Replacing the rest of the¬†ORMA big inspiration for me writing this piece was a project I came across on GitHub a while ago. I initially didn‚Äôt want to go through it to implement it myself, but the wonderful author has made it an actual library. The package is called Zapatos. With this, you can automatically generate TypeScript types from your database (originally inspired from a package called Schemats which is now unmaintained), do somewhat type-checked SQL queries, and get nifty helpers along the way, up to the level of abstraction you‚Äôd like without going overboard. Remember how I was talking about needing to keep the DB in sync with the backend? I don‚Äôt need to do that anymore. Honestly, some of the helpers here are better than what ORMs I‚Äôve seen offer‚Ää‚Äî‚Ääat least for the queries that I‚Äôd use the ORM for. I would highly recommend reading the documentation (it‚Äôs straightforward to understand) and taking a look at it yourself‚Ää‚Äî‚ÄäI won‚Äôt do it justice.\nI see the questions already‚Ä¶ But Ani, isn‚Äôt this just like another ORM?\nIf you use it, you‚Äôll see that it‚Äôs not. It ultimately uses pg and has some nifty helpers to help you do better type-checking, and make certain queries easier. It does not try to write strangely complex queries, manage connection pooling, or do anything super fancy (although generating the types from your database for you is amazing and fancy in and of itself). It‚Äôll convert whatever you pass it to pretty much the exact query you would write if you wrote it by hand (most of the time, with the exception of the highest abstractions near the bottom of the docs). It stays pretty lean in terms of what it offers and what it can do for you‚Ää‚Äî‚Äämost of it is ultimately on you to write a proper query. The files it generates are put directly into your project‚Äôs source code, so you can see exactly what it does.","bonus-part-4-abstracting-the-apiitself#Bonus, Part 4: Abstracting the API¬†itself":"Gotten this far? I thought I‚Äôd give a shoutout to some of the tools that have come in recent years to help build backends faster. Tools like PostGraphile generate a performant GraphQL API on top of your database. They invert the model and turn your development model into database driven design. It‚Äôll teach you a lot about how to use your database‚Äôs powerful features instead of using it like a dummy data store you abstract away through code.Thanks for reading! Please let me know if you have any feedback in the comments below. I haven‚Äôt been writing that much about programming-related topics so I thought I‚Äôd kick it off with a light intro to something I did recently."}},"/posts/software-engineering-in-the-early-days-of-a-product":{"title":"Software engineering in the early days of a product","data":{"":"I‚Äôve been writing code more seriously for a few years now, initially starting off with projects built from the ground up, and more recently, working at a company where I work with a pre-existing codebase. Pretty much all of my software engineering experience comes from early-stage companies doing web development, so I don‚Äôt have the experience to comment on what happens when projects scale to millions or billions of users or niche projects that may have extreme performance concerns, etc.Ultimately, your goal in the early days is to figure out if you can make something people want (in a timely manner). Over time, you want to be able to maintain or create better experiences if you have determined that you are, in fact, solving a real problem. The following contains some themes I think anyone looking to build something from the ground up should think about from a software engineering lens. Many of them are intertwined with each other so you can expect overlap between the themes.1. The tools you pick, particularly in the early days, matter way more than people give it credit for.2. The team you build will make or break your engineering capacity.3. High-quality abstractions are the lifeblood of your codebase.4. You are not always liable for the debt you create - but someone eventually will be.5. Deleting code is a feature.","tools#Tools":"I hear a lot of engineers say \"programming languages are just tools\", as though tools don't matter all that much and you can pick whatever you want to solve your problem. Not all tools are created equal. Different tools certainly come with different tradeoffs, and I've come to believe after observing at least a few startups now that engineers in the early days should take these tradeoffs more seriously (and consider them in the first place).The tools you choose in the early days will have an outsized impact on everything you do:\nThe team you are able to hire\nThe velocity with which you ship\nThe quality/experience of your product\nThe quality/maintainability of your code\nScaling all of the above as the team grows\nYou can make the case that there's actually no choice more important than the tools you choose in the early days - they will stick around longer than you think, potentially even longer than the early people you hire. Someone will pay the price for choosing or working with improper tools - the engineers, your users, or all of the above. On the other hand, great tools can give you incredible leverage - which is what good technology is supposed to do for humans in the first place right?The more of your team's standards you can enforce with tools, the better. For example, aim to have styling practices and code patterns enforced more by tools, so people don't have to think about it and can't easily make an excuse to avoid it. If you can do this early, it's nice to have because it's a lot more work to fix when you have many lines of code.Choose high-quality tools that allow you to work with more than one engineer. For example, choose a statically-typed language . You can move faster when the computer does so much of the work for you, and as a startup's product continues changing, you have an aid that can help you make changes with much less brainpower on the code itself. Shift your focus to actually building something your users want, and spend less time fighting with code. When your codebase is more than 10 lines and has multiple people working on it, you cannot sanely keep everything the code is doing in your head. Use a computer for what it's good at. More time can be spent writing tests to test actual workflows (i.e. the stuff that can't usually be checked by a type system).Don't skimp on using tools such as a production-ready, battle-tested database like PostgreSQL. Eventually the remainder of your non-technical team will look to understanding your data. If you don't take data modeling and storage seriously, it will be painful not only for the engineers, but for the entire business.Improper tool choices can cause a real burden on your team, and potentially leave your team with things that are difficult to change years later. Especially if you choose to build with a stack of tools (programming languages, etc.) that turn out to not be maintainable even with your existing team not having grown at all. It's possible to make it by with improper tooling, but remember to ask yourself: should you?The tools you pick always have tradeoffs you have to weigh, and there are no silver bullets in software engineering. Just be more thoughtful about what tradeoffs matter to you. If you weigh your tradeoffs well, your team will be able to maintain decent velocity over longer periods of time, hire less, and ship higher quality code. If you choose poor tools, the burden on your team will increase drastically as the amount of code/complexity increases, your product quality will suffer (i.e. more bugs/errors), and your team will struggle working with your codebase over time.Ultimately you want your tools to help get you closer to delivering a high-quality experience for anyone using what you are building, and reduce your burden to deliver that experience.","team#Team":"Neck and neck with your tools is the team that you build. Your team will inform the tools you are able to work with - a more experienced team that's also passionate about their craft can probably use tools that other startups couldn't use, giving them an edge over the competition. When you're building a technology company, it should be easy to reason about why having a technological advantage can be a good thing. But not every team can make use of certain technological advantages, cause it may be too out of reach for your team.You want a team willing to learn new things, even if it takes effort. When you have a team that's not passionate about their craft especially in the early days of a startup, it will show. The last thing you want is an idea that was really poorly executed by engineers in such a way that users don't even want to use your product. Granted, it's important to understand engineering is a huge iceberg - there's a ton of work that goes on behind the scenes to make things work at all.","abstractions#Abstractions":"Writing high-quality code from the outset has a fair bit of inertia, which is why it's easy for engineers to ignore it and hack together whatever works. There's a balance here - maybe a specific feature hacks something together to make it work, but the fundamental pieces of your codebase that are copy/pasted everywhere should be written with intention and real effort. While it's more work to write \"primitives\" (e.g. helper functions, wrapper around libraries you use, design patterns in your codebase, UI components etc.), it increases development velocity a lot when your primitives are good. It makes maintenance easier, and your applications will \"just work\" for longer with less effort from you. Solve only the actual problems you have in your codebase today, and as your needs evolve, your code can be changed (with a good type system helping you easily refactor)!Your ability to choose/build high-quality abstractions will evolve as you improve your craft, and more of your software touches the real world. Your abstractions will also improve over time - they will likely not be stagnant as your codebase and product needs evolve.One example of a paradigm that I value in codebases is functional programming. As I've spent more time writing code, I've realized functional programming allows for cleaner and more maintainable abstractions, and a lot of the ideas in functional programming have permeated into most mainstream languages/frameworks. On a small team that's ambitious and might have a large product to build, making it easier to reason about code while having less bugs/errors/crashes is generally a good thing .If it takes you an extra week or two to build high-quality components for your team to work with, or reusable abstractions to build a high-quality API, do it. And if you're willing to learn, explore other patterns for writing and organizing code.You may be surprised how the things you introduce will infect your codebase and be everywhere before you know it, so try to at least be intentional about this. Being able to write code that can be read and made sense of (with high-quality types, function names, components, etc.) takes more effort, but it allows you to maintain velocity over time while not degrading in quality and introducing lots of regressions. I generally find that writing stuff with functional programming principles in mind means that it may take more brainpower and effort to write it the first time, but it becomes much easier to maintain and reason about longer-term.","debt#Debt":"There's primarily three types of technical debt in the early days:\nThe \"debt\" that's incurred because you've learned or found a new tool/library/language that's better for solving your problem than what you currently do.\nThe debt that's incurred from knowing you wrote code in an ugly/hacky way the first time to move faster, but at the cost of requiring cleanup or needing to be completely redone long term.\nThe debt that's incurred from the system not being designed in the optimal way to continue producing based on your users and company's needs, which you may only find out later.\nPaying down technical debt becomes more difficult over time for a myriad of reasons. It's harder to justify spending time on especially at a small company that's just trying to survive, and even harder to justify if the rest of your team doesn't have hands-on experience building a product. However, it is necessary, and your team should be willing to take strides toward paying some of this down over time. If you don't, it slows down the entire product development lifecycle and everything you ship will degrade in quality over time. It's like a house - it needs to be maintained over time, and sometimes renovated entirely.Most engineers also don't think as much as they should about how their debt creation doesn't only affect themselves in the current moment - it affects your future self, and the rest of your team too. Every amount of debt you add is a collective debt that the entire team has to deal with, even if you end up leaving the team. Be thoughtful about increasing the burden on your team. Little or no thought into this can lead to large swaths of your codebase needing to be rewritten or worked on by you, or someone else on your team that joins later. If you can avoid it, there's no need to put that burden on someone else.","deletion#Deletion":"As a product grows, it builds up cruft. Technical debt increases, and unused features take up space in your product and the code. The best code is no code. If building higher quality abstractions allows you to delete code, that is a great thing. If you can simplify your product and delete stuff, that is also a great thing. More code generally means more maintenance burden. Deleting code is definitely a feature. If you can find ways to delete code with little effort, be happy to do it. Even if it means something you spent hours, days, or weeks building should just be removed completely. Lines of code is a vanity metric. More code is not necessarily better (for the record, it's also not always a bad thing).","final-thoughts#Final Thoughts":"When I first started building products, I used to get excited whenever people said they \"hacked\" something together. I thought it was a badge of honor to just get something working. I don't hold that belief anymore. While there is a time and place for hacking things together (especially when you're early and your only concern is building a product people actually want and get your business to go from \"default dead\" to \"default alive\"), there are some things that most people overlook in the early days and certain decisions that can be made that continue to affect your team longer than you think. If you're really building something people want and you've gotten the signals that you are, take what you're building more seriously - if people depend on your product, you can't only be focused on the 1000 foot view of the product - the manufacturing and assembly matter more than people give it credit for in the early days. Sometimes I feel as though people who build physical products probably understand this more intuitively than people who build software - cause when a physical product sucks, wow can you feel it. Everyone else at your company has different priorities - someone wants to get something solved for a customer, someone else wants to improve the business, etc. But you, the software engineer? Your job is to build a high-quality experience that people can use to solve their problem and to write code that other team members feel empowered working with to continuously deliver those high-quality experiences.If you are interested in functional programming, it's up to you to decide how deep you want to encourage its patterns. You could use an esoteric language like Haskell if you're more experienced and want to go all in, or use something like TypeScript that everyone knows and use the libraries/linting tools necessary to enforce a functional style, even if it's not as ergonomic as in languages built from the ground up to be written in a functional style (Haskell, OCaml, F# etc.). You may decide you want to build your frontend UIs in React.js. A lot of React is heavily inspired by functional programming ideas.It makes no sense in 2022 to be shipping buggy and hard to maintain products with dynamically-typed languages. We built computers to help us, not to ignore all of their capabilities so we can do a worse job at something a computer is good at. A good statically-typed language will give you the expressive power you need with most of your problems, and for practical reasons, the escape hatches you may need when you don't know how to make the types reconcile (until our tools get better). People often say that you can \"move faster\" with a dynamically-typed language - which if you've read any of my other posts, you know is a view that I vehemently disagree with.The challenge with functional programming is it's not the first paradigm people learn (most people learn imperative/object-oriented programming with Java, JavaScript, or Python), and it's an entire system of programming that changes how you look at programming from almost the ground up. It's a big mindset shift for someone who has already been programming for a while. The upfront cost is higher, and in a world of developer tools that are supposed to be \"easy to get started\", it's a harder pill to swallow that not everything \"easy\" is great for serious production usage."}},"/posts/special-about-haskell":{"title":"What‚Äôs special about Haskell?","data":{"":"I started programming by learning Java. After taking a break from learning programming, I jumped into web development by learning JavaScript. Unsatisfied, I eventually moved to TypeScript. I‚Äôve seen a little bit of what a few different languages have to offer and have dabbled in some others not mentioned here.So what‚Äôs special about Haskell?I didn‚Äôt know anything about functional programming until about a year and a half ago‚Ää‚Äî‚ÄäI had no idea that the things I liked most about programming actually came from functional programming. I was later introduced to ReasonML and eventually found Haskell.Haskell seemed like a mysterious beast at first. I didn't understand the syntax at all, and it looked different from any other language I had used. It seemed hard to read. Looking back, the things I found so confusing make so much sense, and I only found it so hard to read even basic code simply because I was unfamiliar, not because there was anything inherently difficult to understand.One effect of learning Haskell is that it completely changes the way you think about writing programs, coming from a background like mine. This also means that there will be a greater learning curve, and it‚Äôs unlikely you‚Äôll make the leap unless you‚Äôre forced to or you‚Äôre interested in learning it in the first place. I have had a hard time convincing people as to why you should learn it, also due to the fact I am still a complete beginner.The most novel things that blew my mind coming from other languages were:\nWay more sophisticated type inference. It repeatedly demonstrates to you that types are not just for error checking as is a common misconception and reductive view of the real power of type systems. Types are meant to be composable specifications to help you model your programs. Good types make refactoring fearless, as your application grows in size and you will be making changes often. The more of your domain that you can model in the type system, the more the compiler can help you make sure you‚Äôre doing what you told it you would. It‚Äôs a conversation between you and your compiler.\nAbility for the type system to track things that are side effects vs pure functions. A pure function is a function that only does what it needs to do with its inputs and returns back the same output given the same input (like in math!). For example, an add function that adds two numbers will take two numbers and return the addition of those two numbers, nothing else. If it did a side effect, it might do something like try to log to the console or send an email before adding the two numbers. In Haskell, you cannot just send an email inside of a pure function without changing the type of the entire function to indicate a side effect will be performed. By isolating the pure from the impure, it‚Äôs easier for you, the programmer, to understand what your code is doing (or intending to do).\nConcise code, and robust abstractions (aka tools for you, the programmer to use) built on mathematical foundations. Haskell gives you a new set of building blocks and primitives upon which to build your programs, many of which are not the same as the ones you may be very comfortable using in other languages, such as for loops. Haskell has its warts, but many of the ideas you‚Äôll encounter even simply by starting to learn the language have been built with rigor and decades of research.\nWhat‚Äôs most important about number 3 is that any living codebase will increase in complexity, even if it doesn‚Äôt grow in size (aka lines of code). To be able to manage this well, you need the right tools.Something I find to be a big problem in programming is we‚Äôve taught programmers to expect immediate results and immediate positive feedback from starting a new project.‚ÄúYou mean I can‚Äôt spin up a production project in 5 minutes??‚ÄùHaskell is one of those things you learn because you are willing to pay the upfront cost to have an easier time managing complexity down the road. Just because something looks easy right now doesn't mean it will be easy as your project grows. There is always a cost. Haskell pushes more of the costs upfront (making you reason about types, new things to learn) instead of giving you the easiest possible onboarding and leaving you to think that the tools are powerful enough to grow with you as your project grows. We have a job as programmers to use the best tools at our disposal to build the most reliable programs.If you are looking for a batteries-included dive into Haskell web development though, check out IHP!Nothing I‚Äôve mentioned thus far is what I‚Äôve found most compelling about this language. So what‚Äôs special about it?Haskell is the first language I‚Äôve learned that makes you reason about what code means, not what it does. Whenever I learned how to code, I always wanted to do some set of actions to accomplish a particular goal. When I wanted to learn how to put stuff in a database, I learned the basics of whatever tool I needed to insert data into a database. When I needed to render something on the UI, I learned a frontend framework to make UIs.For the first time in my life, a language has made me interested in programming in itself‚Ää‚Äî‚Ääto reason about code at a higher-level and learn how to use the vast array of tools available in Haskell to express your constraints and domain. Things I would‚Äôve never been interested in learning before learning Haskell (e.g. something like category theory) are now suddenly interesting because it underlies a rich history of ideas that you can use to write concise, robust, maintainable, understandable, and composable code. Composable meaning that you can build one lego block of your program at a time, and put them together nicely with the tools afforded to you by the language. The building blocks can look simple at first, just like they often can in math, but how you put them together makes all the difference.I‚Äôm still a beginner at Haskell. I‚Äôve barely touched the surface, and am just dipping my toes into writing some actual programs with it outside of my day job. I worry I will never be able to enjoy ‚Äúregular‚Äù programming again, however, I feel like I‚Äôm already getting to that point. If you are interested at all in expanding your mind as a programmer, and being able to learn lots of good ideas to improve your programming skills overall, learn some Haskell. It turns out a lot of the cool things you learn in Haskell help you write better code in most languages you will use nowadays because you aren‚Äôt only learning a new language, but also learning new ways to think. Haskell is often at the edge of programming language research‚Ää‚Äî‚Ääthe capabilities you see in Haskell are eventually picked up by more mainstream languages."}},"/posts/stand-out-engineering-team":{"title":"How to make an engineering team stand out","data":{"":"As I've been reflecting on work I've done that I enjoyed vs work that I didn't, one thing has consistently stood out to me. Each opportunity had something that stood out about the engineering or product culture. The thing is, there are a lot of different levers you can pull here, and it's interesting seeing teams that don't pull any of these levers (the most boring jobs to work). The following are a (non-exhaustive) list of ways an engineering team stands out:","1-unique-language-choice#1. Unique language choice":"Some companies stand out because of the tooling they use to build their technology, which has a huge influence on a lot of other decisions, as well as the people who are attracted to your team. For example, a company like Bun uses Zig, an unconventional language choice. A good friend of mine loves ReasonML/OCaml. It's not that you have to have a large audience of people who agree with your tooling choices - but having some opinion gets you to stand out for the right engineer.","2-unique-approach-to-using-boring-tools#2. Unique approach to using \"boring\" tools":"Many companies pride themselves on using \"boring\" technology - they don't want to use anything too new, just things that are tried and tested. A company that sticks out meaningfully amongst the sea of companies like this is Zerodha. They self-host and use open-source software for their entire technology stack. When I say everything, I mean literally everything, including their HR systems to manage their employees. It's a incredibly rare but principled approach to building technology, and one that most wouldn't recommend for a variety of reasons, but they made it work. They have a product team of ~30 engineers and do $800M in revenue, entirely bootstrapped (as of 2023), and almost no PMs or designers.","3-compensation#3. Compensation":"Companies like Netflix stand out because they project a culture of high-performance, high-pay. Others may offer unusually high equity. How effective this is on its own to attract great engineering talent is up for debate, but it's certainly a useful lever for those who can pull it.","4-autonomy#4. Autonomy":"I've worked at a startup that offered me significant autonomy, almost to a fault. Due to that, I learned so much about building products. When you give people who deeply desire self-actualization the proper space to do so, it's surprising the magic you can create with the right guardrails in place.","5-unique-problems#5. Unique problems":"Some products are built based on solving things that have never been solved in history, or otherwise extremely challenging problems. Like Sam Altman says, it's easier to build a hard company than an easy company. Sometimes interesting problems are hidden in plain sight, and it might require some communication on your part to show engineers why it's an interesting problem. A lot of seemingly boring problems (e.g. something to do with taxes) can easily be written off if people don't get a strong sense of why it might be interesting.There are many other levers one could pull, such as a unique approach to product or design, working on open-source projects, etc. But there has to be something. You can't offer average/below-average pay, no interesting problems, no autonomy, and also have no unique approach to your technology, assuming you want to attract engineers that stand out. Pretty much every engineer that I've worked with that stands out amongst other engineers has something they care about or some unique approach to something that puts them ahead of other engineers (this is basically a tautology).There are a variety of reasons why a company may lack a good engineering culture (or a culture at all). For example, smaller companies can often have engineers that aren't experienced or thoughtful enough to make principled decisions, and just do whatever it takes to get the job done.On the contrary, I've actually worked at a company with experienced engineers that took pride in this extreme simplicity. They wanted to use the most tried and true technologies, in the same way everyone else does. And none of the other levers I mentioned were pulled either. Unfortunately in today's world, I don't think that works to attract engineering talent. Great engineers care about things that bring meaningful improvements to their life, whether that's building a unique or standout skillset, new knowledge, higher pay, and/or autonomy. You can't avoid offering all of these things and expect to hire capable talent. If I put your company on a map next to a bunch of other companies, why should anyone work for you over anyone else?"}},"/posts/starting-a-company":{"title":"Musings on starting a company","data":{"":"Generally, I think people shouldn't start companies, if you can find any easier way to accomplish what you want to do. You're signing up for so much pain and uncertainty, that it's probably better to see it as something closer to a last resort than a first resort. If you can accomplish what you want through any other role or an existing company, honestly, just do that.So why am I writing this?Coming out of high school, I caught the startup bug - not enough to know what to do or have any useful skills, but I became captivated with founder stories and tried to surround myself with people that were doing things. Funny enough, some of those same people later told me they weren't sure if I was just a \"networker\" or going to work on anything. Most people only ever get far enough to say they want to start a company, and never take any steps whatsoever to do it. What felt different for me is that I simply chased after what was interesting to me, and was willing to put any amount of effort necessary to keep doing things that were interesting to me. This led to me to joining my first startup (after trying to start my own company but not knowing what to work on, which fizzled out after building a couple small apps), where I got a one-of-a-kind experience. I don't think I appreciated how unusual my experience was until I talked to more people and learned about their backgrounds (as well as hearing from former teammates about their current roles). The startup ultimately failed, but coming out of it, I wasn't sure what to do.I tried working at some other startups, and couldn't even last more than a few months. What was going on? It took a lot of soul-searching, but I realized I had reached this unique mental state I've heard some founders describe, where you feel like you have to start a company and genuinely can't do anything else. My first startup gave me so much autonomy that it basically made me unemployable - working anything that felt even remotely similar to a normal job was unbearable and super boring for me. I wanted to own way more of the decision-making, the company, and truly feel connected to the problem/customers.I like using the metaphor of being inside a box to describe the jobs I like vs dislike. Jobs where I feel like the box is minuscule, and I can easily touch every boundary are boring jobs to me. At my first company, because I was a lot more inexperienced, the box I was in for that role felt nearly unbounded, despite mainly working only on technology and product. I've done that now, and no longer see my previous roles as an unbounded box. I think the next unbounded box is starting a company.I kept psyching myself out after that first startup experience and told myself that maybe what I wanted was closer to a regular job, \"work-life balance\", and all the things people usually say they want out of life, only to quickly realize it wasn't working for me. No one should sign up for the pain of starting a company unless it's truly so compelling that they can't help themselves, and I didn't know I'd get to that point. I told myself for years that I'm better off being an operator at an early-stage company (because I still liked being early and owning many product decisions), but I thought I wasn't \"founder\" material. It was only at the point where I felt a deep desperation to start a company and genuinely couldn't be excited enough to do anything else that I realized I had to do it, and didn't need to wait for anyone's permission."}},"/posts/the-future-of-typescript":{"title":"The future of TypeScript","data":{"":"The TypeScript ecosystem has seen a ton of development and tooling in the past couple of years. The JavaScript ecosystem has a reputation of having a lot of mediocre projects that regularly churn, and I think this is a fair criticism. However, the best of the best in the JS ecosystem allow for building apps in production that really do work, and work well.While Node.js has given TS/JS a backend story for many years, it hasn't been the greatest one. A lot of the tools available do not scale as well as libraries and tools in other ecosystems, and TypeScript itself is a fairly simple language, requiring a lot of libraries to write safe and high-quality code.Enter Effect, a revolutionary approach to writing TypeScript. Effect is the result of years of development, and recently, fp-ts, another well-known project in the TypeScript ecosystem for functional programming enthusiasts, decided to join forces with Effect. Effect today reminds me of React in the early days - a small group of extremely excited enthusiasts, and a world full of people that didn't know what it was or didn't fully absorb its greatness."}},"/posts/toy-project-not-ready-for-production":{"title":"Your toy project is not ready for production","data":{"":"As I‚Äôve been building products with Ethan Naluz, one thing we re-learn time and time again is that making software robust in unpredictably different environments is tough. It‚Äôs easy to build a toy project and say that you learned how to use some new tool, library, or language quickly, but the real work in software engineering is in the last ‚Äú10%‚Äù. It‚Äôs to make something run in a production environment, not just on your development machine. Have a view that sometimes renders correctly or has a strange breaking edge case that you notice? You can ignore that in a toy project, but it has to be taken care of for a proper experience in production. Your WebSockets don‚Äôt reconnect when the server restarts? You can handle this fine with a toy project‚Ää‚Äî‚Ääjust restart the server. In production, stuff like this HAS to work.With the current idea that we‚Äôre working on, we had a prototype in a few days and a more production-ready prototype within a few weeks. We realized that the way we built it had no chance at scaling one particular feature in the event that we got users (and would be painful to re-architect after getting users), so we had to go back to the drawing board for pieces of it. Prior to working on our current idea, we had worked on a robocall-blocking app called Pepper. We tested it again and again on our machines, getting the experience to what we thought was ‚Äúgood enough‚Äù. Guess what happened when we shipped? Issues across the board for users, largely due to things not under our control (on the bright side, people still really wanted it).Don‚Äôt even get me started on DevOps. Your toy project can run locally or on a tiny Heroku server and get through the day. Guess what, now you need to manage state across 5 servers, and can‚Äôt duplicate certain information. You have socket connections across 5 servers and need to manage how your connections hit the servers. Security? Whoops, turns out that your web service can be accessed publicly and has no way to stop people from connecting to it. Looks like people can easily flood you with requests too as long as they know what to send you. And on and on...All of the things that don‚Äôt matter when your software is being used by 100 people will painfully crush you when it‚Äôs being used by 100,000 people. Of course, most of us building something from the ground up only dream of having 100,000+ users in the first place, so there‚Äôs a balance to not over-optimizing or trying to make everything perfect. The bar for having a decent experience with your software does seem to have gotten higher though, as we‚Äôve gotten accustomed to good design and smooth experiences.I haven‚Äôt written that much about the technical lessons we‚Äôve learned throughout our time building things, but I may start writing a bit more about that."}},"/posts/understanding-users-is-actually-difficult":{"title":"Understanding users is actually difficult","data":{"":"One of the things I've learned after working with a few startups now is that the advice \"talk to your users\" is not just extremely important, but way easier said than done. Even if you talk to your users, it's difficult to predict what people will actually do, especially if your product is complex. You have to get really good at getting people to talk through how they do things and describe problems, rather than telling you the solution (let them do that too, but you probably won't use their suggested solutions). If you don't actively observe your users or ask them how they do things, you may never get feedback on how things are going.We found that after we talked to our users, we were astounded by how much inefficiency they dealt with using the software to do their day-to-day jobs without complaining. It was surprising how our users just wouldn't say anything even if they're spending insane amounts of time doing something inefficiently or repeatedly.Once you've committed to having engineering time focus on one of the aforementioned problems, you also have to follow up with your solution and see if it actually helped them. It's easy when you're a small startup with so many things to do to simply ship something and forget about it, thinking it's solved your users' problems, only to realize that it didn't move the needle on what you expected it to. Sometimes, the solution was good enough at a certain scale, and then something changes in your business (i.e. you grow a lot) and then that solution is super inefficient again (assuming it was ever a good solution in the first place).Building products is hard - you can write a lot of code and build a lot of features, only to realize your users aren't using them how you expected at all, even if your users are on your own team. Sometimes they don't even use the features, period. It's cool to see how much progress a small team can make, but building a bunch of features that don't get used isn't progress - it becomes a liability.Building products requires encouraging feedback from users, actively listening to them describe what their goals are and how they use your product to accomplish their goals, and actively working on tuning the software experience to encourage the intended usage of your tools.You'll find blog post after blog post talking about this same stuff, and there's a ton of videos on how you should \"run product\". At the end of the day, you may find you'll still make most of the mistakes everyone talks about, and that it's genuinely harder than it looks. It's a muscle you have to put deliberate effort into building."}},"/posts/why-i-bought-a-framework-laptop":{"title":"Why I bought a Framework laptop","data":{"":"As Framework began to start showing up in a lot of tech news, it piqued my interest. I've been interested in computers from a fairly young age, but more so only because I wanted to understand how they worked. I've never found a particular laptop company interesting in my entire life because they've all felt the same, at least since the time I've been able to own one. Laptops had already become streamlined into some of the form factors you see them in now by the time I got my own.However, once I found the Framework laptop, I was interested in a laptop as a product for the first time in my life. I was initially skeptical, not knowing anything about the company and who was behind it. There are a graveyard of products and companies that have tried to do repairable/upgradeable consumer electronics, and only a few are still alive. I realized the Framework team must be a special one when I saw the initial prototypes that the founder, Nirav Patel, showed off in some YouTube videos (e.g. Adam Savage's Tested Initial Hands On). Even though the laptop is repairable/upgradeable, it looked super well thought out, inside and out (and I'm not one that cares for the current trend of making laptops pointlessly thin, but don't want something really bulky if I can avoid it). Not just that, they thought through every little detail - giving you extra screws, making the screws that hold the back captive so that they don't detach from the case when you loosen them, giving you a screwdriver in the box that can unscrew every screw in the laptop, etc.I later learned that Nirav was the head of hardware at Oculus and one of the first folks on the Oculus team. The rest of the Framework team has some really talented people from other companies as well. I also learned that they raised a $9M seed round, with Nirav himself leading the round - which shows incredible conviction. Finally, a company had the know-how, talent, and mission to see this challenge through. You can tell this company is built by engineers and engineers-at-heart. I was hesitant to buy one for the longest time, because I actually didn't want the initial configurations that were available, as I didn't feel like it justified an upgrade from my current laptop. However, I ended up buying one because:\nI would tell everyone about this company, but I didn't even have the laptop. I wanted to put my money where my mouth is.\nI knew that if everyone was hesitant like me, the company would be dead before it could reach its next milestone.\nDon't get me wrong, it is still meaningfully better than my current laptop, but I initially couldn't justify the upgrade. However, I upgraded because I wanted to support this company. I think more products should be built this way, not just because they are way more sustainable, repairable, or upgradeable, but also because as an engineer, knowing that you have easy access to play around with the tools you use is fun! üòÄI would recommended some of the content below to better understand the laptop and company:Framework's website (they have community forums, a blog, and several other resources to scour)Just JoshElevated SystemsiFixit TeardownAdam Savage's TestedThis Week in Startups with Jason Calacanis - Interview with Nirav PatelFreethink Profile on Framework"}},"/posts/working-on-things-that-are-fun-but-dont-matter":{"title":"Working on things that are fun, but don‚Äôt matter","data":{"":"As Ethan Naluz and I keep working on new projects, something we‚Äôve found up until now is that we‚Äôve never worked on something that we deeply cared about. We first worked on a robocall-blocking app called Pepper, and then we worked on a product called FoodFeed, which was social media for foodies. We also¬†worked¬†on¬†a¬†few¬†other¬†things. While we learned a ton from building and built new skills each time, what we found was that as much as we could code all day, we didn‚Äôt feel a deep passion for anything we built. There was no founder-problem fit. We decided to go back to the drawing board and find something that mattered to us."}},"/posts/your-database-is-all-your-are":{"title":"Your database is all you are","data":{"":"I‚Äôve noticed a misguided approach in the broad web development ecosystem where programmers learn how to build real web applications while simultaneously ignoring the database almost entirely. While NoSQL databases have their uses, this is often how they are misconstrued when beginners learn web dev (I fell into this trap too, a few years ago). SQL databases are thought of as ‚Äútoo rigid‚Äù, or ‚Äútoo structured‚Äù, and you are told that you need some kind of tool that ‚Äúhides away the complexity‚Äù so you don‚Äôt have to think about the database at all and just build your app.This is a horrendously bad idea.Data is the lifeblood of your application. Everything you are as a project/company, everything you will be, is all encoded in that data you are storing, typically in your database or a third-party service you‚Äôre using. ‚ÄúSchemaless‚Äù databases for most new applications, especially ones where you only have one database and it is the primary one, is an outright mistake. If your data has no schema, why are you building anything in the first place? Data always has a schema‚Ää‚Äî‚Ääyou only choose whether to make it implicit or explicit‚Ää‚Äî‚Ääwhen building most products, making it explicit makes a lot more sense. A lot of data tends to share some kind of relationship with other data. The best widespread tool we have to solve that problem is a relational database, like PostgreSQL.Don‚Äôt ignore the data and think that you can come back to it later. Your project/company is nearly worthless without that data in the database. Know what the data is and explicitly define the structure so you can manage its complexity. If you don‚Äôt know what something is or can‚Äôt define it, you can‚Äôt reason about it in your code. It‚Äôs why you see most projects that use MongoDB use something like Mongoose. Cause guess what? It turns out that even if your database enforces close to nothing, you as the developer need to care about what data is being stored and the shape in which it is being stored. Mongoose attempts to put a lackluster SQL-like layer on top of a ‚Äúschemaless‚Äù database. What happens if the structure of your data changes? Then, you have to write a migration. When you have a database that enforces constraints and structure, writing migrations are much easier because it‚Äôs harder to make mistakes. When you have no structure and no constraints, you can run migrations in production that are halfway broken without even realizing they are wrong, wondering why your application suddenly stopped working.Data is a set of facts. You can‚Äôt fix bad data that was inserted wrong in the first place, because you don‚Äôt know what the proper data was supposed to be. Don‚Äôt get your facts wrong, and use a tool that gives you the power necessary to define your facts."}},"/posts/first-product-journey":{"title":"The short-lived journey of our first product","data":{"background#Background":"Around March 2019, Ethan Naluz and I wanted to explore building a side project idea that we had, after exploring a huge problem space around getting benefits for gig workers (we didn‚Äôt do any work here‚Ää‚Äî‚Ääjust explored the space). We wanted to figure out if we could somehow build the reCAPTCHA for phone calls, where someone has to press a random number before the call goes through. We were both getting robocalls, and we were getting tired of them.Our unique insight was that instead of assuming that everyone is safe until proven guilty (as most spam blocking apps do), we assumed everyone was a spam caller unless proven otherwise (they were in your contacts or successfully passed our prompt).","first-prototype#First prototype":"We started working on a prototype to see if this was possible, and after nearly being discouraged, we found a way to make it work using a free SIP service called OpenSIPs (we later used Linphone because they had an app and it worked more reliably until we built a mobile app and got rid of our reliance on this service entirely). After this, we built a basic prototype within a few weeks that we started using live for ourselves. The prototype consisted of a backend that relied on you call forwarding and having a SIP app/account to receive calls. We did not need to build a UI ourselves for this prototype. We realized that we might be able to turn this into a product, so we started working on a web version of the application over the next few weeks as we were more familiar with web development and knew nothing about mobile development. Around this time, we called it ‚Äúdigital receptionist‚Äù because we didn‚Äôt have an actual name yet.Around May 2019, we had a nearly finished version of the product but had to go to San Francisco for summer internships at young Y Combinator startups. We had several work projects that consumed our time so we wanted to wait to launch the product, now called Pepper (Iron Man, anyone?). We didn‚Äôt feel right about launching a paid product to customers if we didn‚Äôt feel like we could be on top of customer support. While in SF, we got to demo the experience by happenstance to several people (I personally got to demo it to a few people at Y Combinator and a VC at Founders Fund as I was interviewing for a potential job at a portfolio company). Once we came back from San Francisco, we decided to finish incorporating our company and get Pepper live.","launching-our-firstmvp#Launching our first¬†MVP":"We launched our minimum viable product (MVP) on the web quietly to a few of our friends. Some of our close friends signed up, and we promptly saw how bad the experience was. It was so bad that people couldn‚Äôt comfortably make it through and have any clue how to actually use the product. We had a feeling this would happen and knew that it was a less than stellar experience, but we wanted to try. It was a super clunky onboarding experience, where you had to sign up, create a SIP account (which was actually tied to a different service), download that service‚Äôs app, and then attempt to forward your number manually with a series of screenshots that we gave you. Call forwarding is the reason that Pepper worked‚Ää‚Äî‚Ääso if our customers couldn‚Äôt figure out how to do this, the product was useless.","mobile-app#Mobile app":"We went back to the drawing board and decided to learn how to build a mobile app with React Native so we could create the experience we should‚Äôve had from the start. We put our heads down and built out the app. Right before launch, we realized that some parts of our tech stack made things harder for us and we decided to spend a few days moving our entire JavaScript codebase (app and backend) from JavaScript to TypeScript, and moving from MongoDB to PostgreSQL. With TypeScript, we could actually get an idea of whether things worked by compiling the code first and having types instead of seeing the usual JS runtime errors (‚Äúundefined is not a function‚Äù is just my favorite). All of our data was relational, and it made no sense to use MongoDB. We also had to move off Stripe and use In-App Purchases (IAP) on Android and iOS. Apple declined our app when we tried using Stripe, but Google still approved it anyway and we might‚Äôve gotten away with it for some time, but we decided to use IAP for both platforms. We also learned what it feels like to have Google and Apple take 30% of your revenue.Ethan had done a tad bit of work with React Native, but this was the first app we had really built from the ground up. We initially started off using Expo, and later completely ripped it out to use barebones React Native (we needed native modules for several things). This made our app significantly smaller and also gave us more flexibility as we had become a lot more comfortable with this workflow. Going forward, we‚Äôd probably always build apps without Expo if it didn‚Äôt increase the workload by much. Twilio ran all of the calls, so we needed native modules to be able to use the Twilio SDKs. The calls are sent directly from our backend (or more precisely, Twilio) to the Pepper app over the internet.","launch-round2#Launch.. round¬†2!":"As soon as we had our app ready, we launched around November 2019! It took us around 2 months to get the first version done. We were slow because it was our first time making an app (while in school as well) and also because there were several tasks that delayed the launch of our app not related to our own coding speed (random React Native build errors, getting our first app and account set up on the App Store/Google Play Store, etc). We ‚Äúlaunched‚Äù by announcing the app on our social media profiles. The first day was really surprising to us. The app looked promising enough that we had people we had never spoken to sign up to our app and pay immediately before using it. The first page in our onboarding flow was the payment page, as we wanted to see what would happen if we did this. Not long after, we moved this further down the onboarding flow, and also offered a free trial (which we still do) largely motivated by strange issues for customers that we couldn‚Äôt always control.We spent time trying to fix as many of the issues that our early customers reported as possible, and got ready to figure out where else we could share our app. We initially thought we shouldn‚Äôt launch on Product Hunt because we weren‚Äôt good enough, but we decided there would be no harm in trying so we should go for it instead. On PH launch day, we got a little bit of traffic, but we were near the bottom of the list for the products that launched that day. We didn‚Äôt think much would come from Product Hunt, so we were getting ready to put our heads together to figure out where else we could share our app.This is when it got surreal and we learned how incredible serendipity can be when making something. I woke up the next morning to Ethan calling me, and I thought it was strange that I was getting a phone call. I picked up the phone, and he asked me if I‚Äôve checked my notifications. I swiped down and saw hundreds of notifications. I saw a message from a Facebook friend asking how we got featured in the Product Hunt newsletter. I told him that I had no idea, given that I also forgot they had one. I was looking through our upvotes on Product Hunt and put two and two together as to who may have seen our app and written about us.It‚Äôs crazy to think that these two college students from Arizona building their first product ended up in the Product Hunt newsletter, and didn‚Äôt just occupy a small part of the newsletter, but almost the entire newsletter. We came up with some copy that we thought would be enjoyable yet informative and a nice GIF when we launched on Product Hunt (it was a fun inside joke for us, particularly the meditating girl at the end of our GIF), and they used some of the copy/graphics we came up with verbatim in the newsletter (this made us happy)!Our servers were having issues because of the hundreds of people that were signing up, and we were working as fast as we could to address some of the major issues that were breaking the signup flow and spent most of the day together on customer support. After that day, we finally had a little time to go fix more of the issues that customers were reporting. We had another traffic spike when Product Hunt used that same newsletter for the weekly digest, right before we were about to launch an app update that we hoped would fix several bugs (the blessing and curse of attention).We were learning a ton at a rapid pace, and we learned how much has to go right when you make a product. Your sleep schedule can get pretty messed up if you‚Äôre not disciplined. We prioritized responding to customer support messages as soon as possible. I would get up in the morning and the first thing I was doing for a while was responding to all the customer support requests that came in before I started my day. On the development side, we found several new tools that were amazing additions to our workflow (e.g. CodePush, Fastlane). If you‚Äôre a developer reading this, a huge pro-tip is to integrate some kind of error reporting (e.g. Bugsnag) and/or analytics into your app BEFORE launch‚Ää‚Äî‚Ääwe took way too long to do this.We discovered all sorts of things that we never knew before, more than I could possibly recall and enumerate here. For example, Twilio‚Äôs upstream carrier marks certain numbers by the digits you would see on a dial-pad (e.g. +266696687 means ‚ÄúANONYMOUS‚Äù). Looking back, we mistakenly told several customers that the app wouldn‚Äôt work for them when it actually may have. This was because we had restricted all calls to only work inside the US due to the costs for going international and other concerns (but we could support you as long as you had a US phone number). We would see these strange numbers and not realize what was going on, and it took us a while to figure out that these specific numbers meant something. In another situation, we discovered that most of our customers on Apple devices were not getting any push notifications from us because we had missed one line of code in the app. With that situation, we only found out because we were looking at a churned customer‚Äôs info in the database and realized that the token for sending Apple notifications was missing for that customer, and ultimately most Apple customers. We got lucky that we found that issue as soon as we did, but we already had a bunch of customers at that point. These are just a few of many things that had our hair on fire.As things slowed down, we were trying to debug one major problem (people not receiving calls). We tried our best to solve it, but still actively churned customers who were having issues. It felt like we were working with a huge black box and we didn‚Äôt own any of the infrastructure around calls, so we often had little clue what was going on. As much as we love someone else doing the work for us‚Ää‚Äî‚Ääthis can also be a giant double-edged sword. We knew that our app couldn‚Äôt scale if we didn‚Äôt solve these problems.Additionally, the way that our app works is that we have you forward all your calls to us, so we handle all incoming phone calls. We weren‚Äôt sure if the business model would work, given that we get charged per minute with all incoming calls. With our web MVP, we had an ugly pricing scheme with four tiers and usage-based pricing that was far too confusing for anyone to wrap their head around. When we launched the mobile app, we changed that to only be one option (flat-rate of $6/month), hoping it would cover our costs based on some rudimentary spreadsheet modeling we had done. So far, it seems like we‚Äôve made money if you only look at the cost to make the product and the amount we‚Äôre charging customers (our margins aren‚Äôt as great as we would want though). We worried that this price might be too high, but we were (and currently are) college students that were bootstrapping this with our own money. We couldn‚Äôt afford to lose a lot of money on this, particularly when our costs had the possibility of being extremely high.","slowing-down#Slowing down":"Once January 2020 came along, app development was mainly focused on fixing major issues and we mostly stayed quiet. After some time, we weren‚Äôt confident about being able to scale this reliably since we didn‚Äôt own a good chunk of the product experience (because the heavy lifting was largely done by other services). We also recognized something that arguably was the most important thing in this particular situation‚Ää‚Äî‚Ääwe didn‚Äôt care much about what we were building. We initially were motivated by the problem since it was personal to some degree, but we mostly built it because we like making things together, not because we were passionate about the problem. Robocalls are an extremely real problem, but it wasn‚Äôt one that we could see ourselves doing the gargantuan amount of work going forward to actually solve. We didn‚Äôt feel passionate enough about our own product to actually go sell to consumers. Remember, thus far, all the traffic we‚Äôve gotten is organic and from launch sites like Product Hunt and BetaList (we still have people trickling in from those sites to the time of this writing). We shared this feeling even before we had launched the product, but we thought we‚Äôd give it a sincere try just to see what happened. It was an incredible experience, but we knew we wouldn‚Äôt want to take it further in any meaningful way.That brings us to now. Pepper is still running (for now), and we announced to our currently active customers a few days ago that Pepper will continue running but we won‚Äôt actively be working on it or providing app updates (however we are available for customer support if we can help our customers with something). We plan to send another email in the future if/when we decide to shut down the product entirely.We‚Äôve handled around 10k+ calls on our service so far, and have blocked 4.5k+ robocalls (we weren‚Äôt tracking certain calls properly at the beginning, so this number is likely higher). If you look at those numbers, you may also notice something that was just as mind-boggling as one of the stats we saw. The number of potential robocalls we blocked was nearly half of all the calls that went through our service (also remember, we only handle incoming calls).We have amazing customers. After announcing that we were not actively working on this any further, one of the emails we received was the following.Customer EmailThis is one of our customers that wants to keep using and paying for an app that isn‚Äôt being actively maintained. I felt something special in a way I don‚Äôt know how to explain. It may seem small, but it‚Äôs just a joy to see as a maker.We‚Äôve learned a ton and have also learned a lot about the experience of making something, even if the journey from launch with actual users to being inactive was only a few months. We have a lot of respect for anyone that tries to make something people want. We found that we had made something that at least some people wanted. That was amazing to experience firsthand.Thanks to everyone (and particularly our amazing customers that took a chance on us) for coming along for the ride. We‚Äôre exploring something new as we get closer to graduating college. We‚Äôll see how far along we can get!"}},"/posts/the-incredible-irony-of-dynamically-typed-languages":{"title":"The incredible irony of dynamically-typed languages","data":{"":"I come with an extremely strong bias, which is that computers should juggle meaningless minutia, freeing people up to work on more interesting, domain driven problems that actually provide value to the world. In computer programming, the best tool that we have to juggle this meaningless minutia is something called a \"type system\", and a very expressive type system like the ones provided in languages such as Haskell allow you to model your domain in code. With the help from tools, languages, and research that's been around for decades, we can get pretty far with our computer-aided tools. However, the incredible irony is that programmers, whose only job it is to build computers and programs that help us, don't want to use the tools that we have available to us, that make our jobs as programmers sane. Especially when working on teams with multiple people with serious production codebases that are more than 10 lines of code doing real work such as moving money, or handling your medical records.I find it astounding that entire programming languages and entire industries have been built on disregarding good ideas from the past, so programmers can ship bug after bug caused by \"undefined is not a function\" or \"key foo not found in bar\", or \"I expected a Post here, but you gave me a User instead\". Even worse is when the errors are non-trivial, and are deadly silent bugs that would've easily been caught by a type system. Our goal as programmers should be to turn as many domain errors into type errors as possible, so the computer can catch our mistakes and we can go on with our lives. Whenever we need to make important changes to our codebase, we should be able to be focused on solving the actual domain specific problem at hand, instead of having to search through the entire codebase to figure out what data structures, functions, or other pieces were affected because of a particular change that was made. We have tools to help us do this, but we code like we're in the stone age.I'll be frank. I find this type (no pun intended) of programming insane. Coming back to the point I mentioned earlier, isn't it amazing that programmers build things to automate so much minutia away but we don't want to give away control for our own jobs, to a set of tools that could make our jobs so much more interesting than having to spend hours upon hours asking meaningless questions about your code that a tool should answer for you? When a computer can help us write code, we find every excuse to not learn how to use it (e.g. it \"slows me down\") and use subpar tools that rely on exerting double or triple the mental effort and time, just to get more buggy code. That mental effort isn't going toward expanding your mind, learning new ideas, or finding better ways solve problems in your code or in the real world, it's \"where the heck am I using this argument inside this data structure I just changed\" or \"what is the value or shape of the data I'm passing in here\", AKA meaningless questions that programmers, who get paid so much money, should not be spending half their time thinking about (if you think half is an exaggeration, it's not off by much when compared to the reality).Don't get me wrong, I want to get paid as much as the next person. However, it's astounding that we are as efficient as we are, given how much time we waste on nonsense that doesn't have to do with actually solving problems and/or developing more knowledge. Then again, the world is so inefficient that even our inefficiency looks super productive in comparison. That's the only explanation I think of for how we've gotten this far and how we get paid so much given so much code out there is just jungle science and written with very little rigor or attention, using world-class tools that people should be using but don't.There's light at the end of the tunnel though. Programmers are starting to realize that when they work in a team of more than one person, and their codebase becomes completely unmaintainable within a few years, that there must be a better way. And it turns out there is, not because people have new ideas on how to do things, but because ideas that existed for decades are finally being taken seriously by more than a small handful of passionate programmers. TypeScript is mainstream. Rust is seeing a lot of interest from big and small companies alike, and Rust's most unique feature (compile-time memory handling with no garbage collector at runtime) is possible because of research on type systems. Haskell is starting to see more serious interest not just from larger companies, but from startups that are taking off.A lot of effort into the more niche statically-typed functional programming languages and tools (e.g. Haskell, OCaml) has come from volunteer efforts and a few notable companies, as the number of industrial programmers in these ecosystems is still quite small. As more young companies develop talented engineers that push forward serious, statically-typed languages to do real work that can manage the insane complexity behind large-scale software, there's hope yet that programming will eventually become sane, and the tools, much more sophisticated. That's a future I can get behind."}},"/posts/using-elixir-in-production-at-a-small-startup":{"title":"Some reflections on using elixir in production at a small startup","data":{"":"If you've read my previous blog posts, you know that I'm generally biased toward languages that have strong static analysis tools, so less stuff gets put in production that isn't verified by a compiler. However, it's almost inevitable in your programming journey nowadays that you will work in some language with almost no static analysis tooling, at least at most young companies. As much as I love tools that can make programming more sane, it's also the case that programming tools still have a lot of room for improvement, to help aid programmers rather than needing to spend too much time type-wrangling or dealing with unclear errors. I've been using Elixir for some time now, and used to have a more negative opinion of it starting out, primarily because dealing with constant runtime errors was super annoying (still is) and it felt slow to build new features when having to keep all the information in my head. While there are some shortcomings in terms of things I like having in a language, some of Elixir's tools are great.Most people often talk about how networking tooling in Elixir is awesome, since communicating between processes and external servers is basically \"built-in\", so network clustering in Elixir (especially for building things like chat apps) is much simpler than in other languages. However, I think Elixir's \"killer app\" is Ecto, Elixir's database access library, primarily used with PostgreSQL. Ecto is pretty powerful, relies heavily on macros, and makes composing SQL (especially dynamic queries where you chain query fragments together in different situations) really easy. We make use of these aspects of Ecto heavily in production. As much as I love statically-typed languages, I don't know how to make SQL as fluid, maintainable, and as easy-to-use as Ecto does in Elixir. It's actually one of the biggest reasons why we haven't seriously looked at any other backend languages for our Elixir codebase - Ecto is just that much easier to use and makes writing new features that much faster (if anyone knows how I can get composable queries, reusable query fragments, helpers to write things like joins, and raw SQL-level performance from a language like Haskell or Rust, please let me know)!Ecto combined with Absinthe (Elixir's premier GraphQL server library) is a really good combination to get you started - it reduces the amount of code you have to write significantly for doing data access and the performance is good enough. Ecto schemas maintain the associations between different tables, and Absinthe + Ecto can figure out how to query a good amount of data simply by using dataloader and not having to handwrite a lot of joins or other queries. Many of Elixir's most popular libraries make use of macros and DSLs to express ideas in non-standard Elixir syntax (like the two aforementioned libraries), and while it may make things a little harder to understand at the beginning of your journey with Elixir, every engineer I've worked with figures it out quickly.Elixir is still growing but still a fairly young ecosystem, and so there's ever more tools/libraries being developed. It has just enough of the tracing, logging, API, security, DB, and websocket tooling that you need to build a serious app in production. It also has some insane features like being able to directly call or run your production code, and hot code reloading modules in your production process.Every set of tools comes with tradeoffs, and different tradeoffs will affect you in different ways at different stages of your product. It's worthwhile to have periods of reflection to re-evaluate whether you're using the best tools available to you to solve the problems ahead, and thinking through how much effort it would take to change tools if needed. Elixir is mostly a simple language to learn, and can get you started fairly quickly if that's what you're looking for. It's also a decent gateway into some functional programming ideas, but if you're looking for tooling that dives headfirst into FP ideas, I would look at other languages instead. I'm not sure when or if Elixir's usage will dwindle for our product in favor of other tools, but for now, it's taken us quite far!"}},"/tags/[tag]":{"title":"Tagged Posts","data":{}}}