<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" data-next-head=""/><link rel="preload" href="/fonts/Inter-roman.latin.var.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-head=""/><title data-next-head="">Software engineering in the early days of a product</title><meta name="description" content="Some things I&#x27;ve learned about building software in the early days of something new." data-next-head=""/><meta name="keywords" content="Engineering, Technology" data-next-head=""/><meta name="author" content="Ani Ravi" data-next-head=""/><meta property="og:site_name" content="Software engineering in the early days of a product" data-next-head=""/><meta property="og:description" content="Some things I&#x27;ve learned about building software in the early days of something new." data-next-head=""/><meta property="og:title" content="Software engineering in the early days of a product" data-next-head=""/><meta name="robots" content="follow, index"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="48x48" href="/favicon-48.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><link rel="preload" href="/_next/static/css/77087cd6bb0af64c.css" as="style"/><style data-next-head="">:root{--nextra-bg:250,250,250;}.dark{--nextra-bg:17,17,17;}</style><link rel="stylesheet" href="/_next/static/css/77087cd6bb0af64c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-f3e9193dc296f32b.js" defer=""></script><script src="/_next/static/chunks/main-26dce7d670d116cd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-59a1492ff76a845c.js" defer=""></script><script src="/_next/static/chunks/411-6d0ce85a3733d61f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/software-engineering-in-the-early-days-of-a-product-ca4ad7107987242a.js" defer=""></script><script src="/_next/static/KXhJIcI_g-B6HpbMNKIzK/_buildManifest.js" defer=""></script><script src="/_next/static/KXhJIcI_g-B6HpbMNKIzK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>((e,t,r,n,a,o,i,s)=>{let l=document.documentElement,u=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&o?a.map(e=>o[e]||e):a;r?(l.classList.remove(...n),l.classList.add(t)):l.setAttribute(e,t)}),s&&u.includes(t)&&(l.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=i&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><article class="_container _prose max-md:_prose-sm dark:_prose-invert" dir="ltr"><h1>Software engineering in the early days of a product</h1><div class="_mb-8 _flex _gap-3 _items-center"><div class="_not-prose _grow dark:_text-gray-400 _text-gray-600"><div class="_flex _flex-wrap _items-center _gap-1">Ani Ravi<!-- -->,<time dateTime="2022-06-24T00:00:00.000Z">Jun 24, 2022</time><span class="_px-1">•</span><a class="
          _select-none
          _rounded-md
          _bg-gray-200
          _px-1
          _text-sm
          _text-gray-400
          _transition-colors
          hover:_bg-gray-300
          hover:_text-gray-500
          dark:_bg-gray-600
          dark:_text-gray-300
          dark:hover:_bg-gray-700
          dark:hover:_text-gray-200
        " href="/tags/Engineering">Engineering</a><a class="
          _select-none
          _rounded-md
          _bg-gray-200
          _px-1
          _text-sm
          _text-gray-400
          _transition-colors
          hover:_bg-gray-300
          hover:_text-gray-500
          dark:_bg-gray-600
          dark:_text-gray-300
          dark:hover:_bg-gray-700
          dark:hover:_text-gray-200
        " href="/tags/Technology">Technology</a></div></div><div class="_flex _items-center _gap-3 print:_hidden"><a href="/posts">Back</a><span role="button" aria-label="Toggle Dark Mode" class="_cursor-pointer _p-2 _text-current" tabindex="0"><svg fill="none" viewBox="3 3 18 18" width="12" height="12" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" fill="currentColor" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></span></div></div><p>I’ve been writing code more seriously for a few years now, initially starting off with projects built from the ground up, and more recently, working at a company where I work with a pre-existing codebase. Pretty much all of my software engineering experience comes from early-stage companies doing web development, so I don’t have the experience to comment on what happens when projects scale to millions or billions of users or niche projects that may have extreme performance concerns, etc.</p>
<p>Ultimately, your goal in the early days is to figure out if you can make something people want (in a timely manner). Over time, you want to be able to maintain or create better experiences if you have determined that you are, in fact, solving a real problem. The following contains some themes I think anyone looking to build something from the ground up should think about from a software engineering lens. Many of them are intertwined with each other so you can expect overlap between the themes.</p>
<p><a href="#tools">1. The tools you pick, particularly in the early days, matter way more than people give it credit for.</a></p>
<p><a href="#team">2. The team you build will make or break your engineering capacity.</a></p>
<p><a href="#abstractions">3. High-quality abstractions are the lifeblood of your codebase.</a></p>
<p><a href="#debt">4. You are not always liable for the debt you create - but someone eventually will be.</a></p>
<p><a href="#deletion">5. Deleting code is a feature.</a></p>
<h2 id="tools" class="subheading-h2">Tools<a href="#tools" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>I hear a lot of engineers say “programming languages are just tools”, as though tools don’t matter all that much and you can pick whatever you want to solve your problem. Not all tools are created equal. Different tools certainly come with different tradeoffs, and I’ve come to believe after observing at least a few startups now that engineers in the early days should take these tradeoffs more seriously (and consider them in the first place).</p>
<p>The tools you choose in the early days will have an outsized impact on everything you do:</p>
<ol>
<li>The team you are able to hire</li>
<li>The velocity with which you ship</li>
<li>The quality/experience of your product</li>
<li>The quality/maintainability of your code</li>
<li>Scaling all of the above as the team grows</li>
</ol>
<p>You can make the case that there’s actually no choice more important than the tools you choose in the early days - they will stick around longer than you think, potentially even longer than the early people you hire. Someone will pay the price for choosing or working with improper tools - the engineers, your users, or all of the above. On the other hand, great tools can give you incredible leverage - which is what good technology is supposed to do for humans in the first place right?</p>
<p>The more of your team’s standards you can enforce with tools, the better. For example, aim to have styling practices and code patterns enforced more by tools, so people don’t have to think about it and can’t easily make an excuse to avoid it. If you can do this early, it’s nice to have because it’s a lot more work to fix when you have many lines of code.</p>
<p>Choose high-quality tools that allow you to work with more than one engineer. For example, choose a statically-typed language <sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. You can move faster when the computer does so much of the work for you, and as a startup’s product continues changing, you have an aid that can help you make changes with much less brainpower on the code itself. Shift your focus to actually building something your users want, and spend less time fighting with code. When your codebase is more than 10 lines and has multiple people working on it, you cannot sanely keep everything the code is doing in your head. Use a computer for what it’s good at. More time can be spent writing tests to test actual workflows (i.e. the stuff that can’t usually be checked by a type system).</p>
<p>Don’t skimp on using tools such as a production-ready, battle-tested database like PostgreSQL. Eventually the remainder of your non-technical team will look to understanding your data. If you don’t take data modeling and storage seriously, it will be painful not only for the engineers, but for the entire business.</p>
<p>Improper tool choices can cause a real burden on your team, and potentially leave your team with things that are difficult to change years later. Especially if you choose to build with a stack of tools (programming languages, etc.) that turn out to not be maintainable even with your existing team not having grown at all. It’s <em>possible</em> to make it by with improper tooling, but remember to ask yourself: should you?</p>
<p>The tools you pick always have tradeoffs you have to weigh, and there are no silver bullets in software engineering. Just be more thoughtful about what tradeoffs matter to you. If you weigh your tradeoffs well, your team will be able to maintain decent velocity over longer periods of time, hire less, and ship higher quality code. If you choose poor tools, the burden on your team will increase drastically as the amount of code/complexity increases, your product quality will suffer (i.e. more bugs/errors), and your team will struggle working with your codebase over time.</p>
<p>Ultimately you want your tools to help get you closer to delivering a high-quality experience for anyone using what you are building, and reduce your burden to deliver that experience.</p>
<h2 id="team" class="subheading-h2">Team<a href="#team" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>Neck and neck with your tools is the team that you build. Your team will inform the tools you are able to work with - a more experienced team that’s also passionate about their craft can probably use tools that other startups couldn’t use, giving them an edge over the competition. When you’re building a technology company, it should be easy to reason about why having a technological advantage can be a good thing. But not every team can make use of certain technological advantages, cause it may be too out of reach for your team.</p>
<p>You want a team willing to learn new things, even if it takes effort. When you have a team that’s not passionate about their craft especially in the early days of a startup, it will show. The last thing you want is an idea that was really poorly executed by engineers in such a way that users don’t even want to use your product. Granted, it’s important to understand engineering is a huge iceberg - there’s a ton of work that goes on behind the scenes to make things work at all.</p>
<h2 id="abstractions" class="subheading-h2">Abstractions<a href="#abstractions" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>Writing high-quality code from the outset has a fair bit of inertia, which is why it’s easy for engineers to ignore it and hack together whatever works. There’s a balance here - maybe a specific feature hacks something together to make it work, but the fundamental pieces of your codebase that are copy/pasted everywhere should be written with intention and real effort. While it’s more work to write “primitives” (e.g. helper functions, wrapper around libraries you use, design patterns in your codebase, UI components etc.), it increases development velocity a lot when your primitives are good. It makes maintenance easier, and your applications will “just work” for longer with less effort from you. Solve only the actual problems you have in your codebase today, and as your needs evolve, your code can be changed (with a good type system helping you easily refactor)!</p>
<p>Your ability to choose/build high-quality abstractions will evolve as you improve your craft, and more of your software touches the real world. Your abstractions will also improve over time - they will likely not be stagnant as your codebase and product needs evolve.</p>
<p>One example of a paradigm that I value in codebases is functional programming. As I’ve spent more time writing code, I’ve realized functional programming allows for cleaner and more maintainable abstractions, and a lot of the ideas in functional programming have permeated into most mainstream languages/frameworks. On a small team that’s ambitious and might have a large product to build, making it easier to reason about code while having less bugs/errors/crashes is generally a good thing <sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>.</p>
<p>If it takes you an extra week or two to build high-quality components for your team to work with, or reusable abstractions to build a high-quality API, do it. And if you’re willing to learn, explore other patterns for writing and organizing code.</p>
<p>You may be surprised how the things you introduce will infect your codebase and be everywhere before you know it, so try to at least be intentional about this. Being able to write code that can be read and made sense of (with high-quality types, function names, components, etc.) takes more effort, but it allows you to maintain velocity over time while not degrading in quality and introducing lots of regressions. I generally find that writing stuff with functional programming principles in mind means that it may take more brainpower and effort to write it the first time, but it becomes much easier to maintain and reason about longer-term.</p>
<h2 id="debt" class="subheading-h2">Debt<a href="#debt" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>There’s primarily three types of technical debt in the early days:</p>
<ol>
<li>The “debt” that’s incurred because you’ve learned or found a new tool/library/language that’s better for solving your problem than what you currently do.</li>
<li>The debt that’s incurred from knowing you wrote code in an ugly/hacky way the first time to move faster, but at the cost of requiring cleanup or needing to be completely redone long term.</li>
<li>The debt that’s incurred from the system not being designed in the optimal way to continue producing based on your users and company’s needs, which you may only find out later.</li>
</ol>
<p>Paying down technical debt becomes more difficult over time for a myriad of reasons. It’s harder to justify spending time on especially at a small company that’s just trying to survive, and even harder to justify if the rest of your team doesn’t have hands-on experience building a product. However, it is necessary, and your team should be willing to take strides toward paying some of this down over time. If you don’t, it slows down the entire product development lifecycle and everything you ship will degrade in quality over time. It’s like a house - it needs to be maintained over time, and sometimes renovated entirely.</p>
<p>Most engineers also don’t think as much as they should about how their debt creation doesn’t only affect themselves in the current moment - it affects your future self, and the rest of your team too. Every amount of debt you add is a collective debt that the entire team has to deal with, even if you end up leaving the team. Be thoughtful about increasing the burden on your team. Little or no thought into this can lead to large swaths of your codebase needing to be rewritten or worked on by you, or someone else on your team that joins later. If you can avoid it, there’s no need to put that burden on someone else.</p>
<h2 id="deletion" class="subheading-h2">Deletion<a href="#deletion" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>As a product grows, it builds up cruft. Technical debt increases, and unused features take up space in your product and the code. The best code is no code. If building higher quality abstractions allows you to delete code, that is a great thing. If you can simplify your product and delete stuff, that is also a great thing. More code generally means more maintenance burden. Deleting code is definitely a feature. If you can find ways to delete code with little effort, be happy to do it. Even if it means something you spent hours, days, or weeks building should just be removed completely. Lines of code is a vanity metric. More code is not necessarily better (for the record, it’s also not always a bad thing).</p>
<h2 id="final-thoughts" class="subheading-h2">Final Thoughts<a href="#final-thoughts" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>When I first started building products, I used to get excited whenever people said they “hacked” something together. I thought it was a badge of honor to just get something working. I don’t hold that belief anymore. While there is a time and place for hacking things together (especially when you’re early and your only concern is building a product people actually want and get your business to go from “default dead” to “default alive”), there are some things that most people overlook in the early days and certain decisions that can be made that continue to affect your team longer than you think. If you’re really building something people want and you’ve gotten the signals that you are, take what you’re building more seriously - if people depend on your product, you can’t only be focused on the 1000 foot view of the product - the manufacturing and assembly matter more than people give it credit for in the early days. Sometimes I feel as though people who build physical products probably understand this more intuitively than people who build software - cause when a physical product sucks, wow can you feel it. Everyone else at your company has different priorities - someone wants to get something solved for a customer, someone else wants to improve the business, etc. But you, the software engineer? Your job is to build a high-quality experience that people can use to solve their problem and to write code that other team members feel empowered working with to continuously deliver those high-quality experiences.</p>
<hr/>
<p>If you are interested in functional programming, it’s up to you to decide how deep you want to encourage its patterns. You could use an esoteric language like Haskell if you’re more experienced and want to go all in, or use something like TypeScript that everyone knows and use the libraries/linting tools necessary to enforce a functional style, even if it’s not as ergonomic as in languages built from the ground up to be written in a functional style (Haskell, OCaml, F# etc.). You may decide you want to build your frontend UIs in React.js. A lot of React is heavily inspired by functional programming ideas.</p>
<section data-footnotes="" class="footnotes"><h2 id="footnote-label" class="_sr-only">Footnotes<a href="#footnote-label" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<ol>
<li id="user-content-fn-1">
<p>It makes no sense in 2022 to be shipping buggy and hard to maintain products with dynamically-typed languages. We built computers to help us, not to ignore all of their capabilities so we can do a worse job at something a computer is good at. A good statically-typed language will give you the expressive power you need with most of your problems, and for practical reasons, the escape hatches you may need when you don’t know how to make the types reconcile (until our tools get better). People often say that you can “move faster” with a dynamically-typed language - which if you’ve read any of my other posts, you know is a view that I vehemently disagree with. <a href="#user-content-fnref-1" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-2">
<p>The challenge with functional programming is it’s not the first paradigm people learn (most people learn imperative/object-oriented programming with Java, JavaScript, or Python), and it’s an entire system of programming that changes how you look at programming from almost the ground up. It’s a big mindset shift for someone who has already been programming for a while. The upfront cost is higher, and in a world of developer tools that are supposed to be “easy to get started”, it’s a harder pill to swallow that not everything “easy” is great for serious production usage. <a href="#user-content-fnref-2" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section><div class="my-4 border-t-2 mx-auto flex items-center sm:flex-row flex-col"><p class="text-sm text-gray-500">Ani Ravi</p></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/software-engineering-in-the-early-days-of-a-product","query":{},"buildId":"KXhJIcI_g-B6HpbMNKIzK","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>